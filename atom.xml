<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YunJie&#39;s BLOG</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-27T16:20:50.655Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>云杰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity SRP 02-绘制调用</title>
    <link href="http://example.com/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/</id>
    <published>2024-07-27T07:19:54.000Z</published>
    <updated>2024-07-27T16:20:50.655Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-02-着色器和批处理"><a href="#Unity-SRP-02-着色器和批处理" class="headerlink" title="Unity SRP 02-着色器和批处理"></a>Unity SRP 02-着色器和批处理</h1><table><tr><td bgcolor="MintCream">本文重点：<br>    <ul>        <li>HLSL着色器</li>        <li>常量缓冲区</li>        <li>支持动态批处理和GPU Instance</li>    </ul> </td></tr></table><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>创建一个新Unlit Shader。</p><p>【之前看完了《Unity Shader入门精要》，CG语言相对掌握掌握熟练一点，这里跟着教程用HLSL编写着色器】</p><p><em><strong>Unlit.shader</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader&quot;Custom RP/Unlit&quot; &#123;</span><br><span class="line"></span><br><span class="line">Properties &#123;&#125;</span><br><span class="line"></span><br><span class="line">SubShader &#123;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex UnlitPassVertex</span></span><br><span class="line"><span class="meta">#pragma fragment UnlitPassFragment</span></span><br><span class="line"><span class="meta">#include &quot;UnlitPass.hlsl&quot;</span></span><br><span class="line">ENDHLSL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>UnlitPass.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止重复定义</span></span><br><span class="line"><span class="meta">#ifndef CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里定义顶点、片元着色器</span></span><br><span class="line">float4 UnlitPassVertex(float3 positionOS : POSITION) : SV_POSITION &#123;</span><br><span class="line">float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line"><span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment() : SV_TARGET &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><em><strong>Common.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float3 TransformObjectToWorld(float3 positionOS) &#123;</span><br><span class="line"><span class="keyword">return</span> mul(unity_ObjectToWorld, float4(positionOS, <span class="number">1.0</span>)).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 TransformWorldToHClip(float3 positionWS) &#123;</span><br><span class="line"><span class="keyword">return</span> mul(unity_MatrixVP, float4(positionWS, <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><em><strong>UnityInput.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"></span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_MatrixVP;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727175808765.png" alt="image-20240727175808765" style="zoom:67%;"><h3 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h3><p>核心库中定义了更多有用的东西，包括各种变换矩阵、光源信息等。</p><p>在Common.hlsl中我们定义常用的方法，这里包括空间转换。</p><p><em><strong>Common.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Common.hlsl包含了基本数据类型的定义、常用函数等</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要定义这些矩阵，才能编译</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_M unity_ObjectToWorld</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_M unity_WorldToObject</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_V unity_MatrixV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_V unity_MatrixInvV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_VP unity_MatrixVP</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_M unity_prev_MatrixM</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_I_M unity_prev_MatrixIM</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_P glstate_matrix_projection</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Packages\com.unity.render-pipelines.core\ShaderLibrary\SpaceTransforms.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727211225198.png" alt="image-20240727211225198" style="zoom:67%;"><p><em><strong>UnlitPass.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float4 UnlitPassVertex (float3 positionOS : POSITION) : SV_POSITION &#123;</span><br><span class="line">float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line"><span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment () : SV_TARGET &#123;</span><br><span class="line">    <span class="comment">//颜色输出黄色</span></span><br><span class="line"><span class="keyword">return</span> float4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><em><strong>UnityInput.hlsl</strong></em></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"></span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_WorldToObject;</span><br><span class="line">real4 unity_WorldTransformParams;</span><br><span class="line"></span><br><span class="line">float4x4 unity_MatrixVP;</span><br><span class="line">float4x4 unity_MatrixV;</span><br><span class="line">float4x4 unity_MatrixInvV;</span><br><span class="line">float4x4 unity_prev_MatrixM;</span><br><span class="line">float4x4 unity_prev_MatrixIM;</span><br><span class="line">float4x4 glstate_matrix_projection;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727212220987.png" alt="image-20240727212220987" style="zoom:80%;"><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h3><p>每次Draw Call都需要CPU和GPU通信。如果必须将大量数据发送到 GPU，那么它最终可能会因等待而浪费时间。当 CPU 忙于发送数据时，它无法执行其他操作。这两个问题都会降低帧速率。</p><p>如果每个对象都有自己的绘制调用，这无疑会造成巨大开销。</p><p>这里复制刚刚我们自己创建的材质，制作一个包含16个球体的场景，Game窗口的State Panel统计信息如下。它显示了18个批次，其中1次用于天空盒，1次用于清除渲染目标。</p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727214343134.png" alt="image-20240727214343134" style="zoom:80%;"><h3 id="SRP批处理"><a href="#SRP批处理" class="headerlink" title="SRP批处理"></a>SRP批处理</h3><p>批处理是合并绘制调用的过程，可减少 CPU 和 GPU 之间通信所花费的时间。执行此操作的最简单方法是启用 SRP 批处理器。但是，这仅适用于兼容的着色器，而我们刚刚自定义的着色器则不可以。</p><p>SRP 批处理不会减少绘制调用的数量，而是使它们更精简。它在 GPU 上<u>缓存材质属性</u>，因此不必在每次绘制调用时都发送它们。这既减少了必须通信的数据量，也减少了 CPU 每次绘制调用必须执行的工作。</p><p>但是，仅当着色器<u>遵循统一数据的严格结构时</u>，这才有效。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727223909700.png" alt="image-20240727223909700"></p><p>在此处，CPU 仅处理上图中标记为 <em>Per Object large buffer</em> 的 Unity 引擎属性。所有材质在 GPU 内存中都有持久的 CBUFFER，可供随时使用。这样会加快渲染速度，原因是： 现在，所有材质内容都持久保留在 GPU 内存中。 专用代码针对所有每对象属性，管理着一个大型的每对象 GPU CBUFFER。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727223106405.png" alt="image-20240727223106405"></p><p>这张图展示了在Unity渲染过程中，使用标准批处理（Standard Batch）和SRP批处理（SRP Batch）时，进行绘制调用（Draw Call）时的不同步骤。</p><h4 id="标准批处理（Standard-Batch）"><a href="#标准批处理（Standard-Batch）" class="headerlink" title="标准批处理（Standard Batch）"></a>标准批处理（Standard Batch）</h4><ol><li><strong>SetShaderPass（large complete GPU setup）</strong>：开始一个大的完整的GPU设置。</li><li><strong>Gather all built-in data in system memory and fill Object CBUFFER</strong>：在系统内存中收集所有内置数据并填充到对象常量缓冲区（Object CBUFFER）中。</li><li><strong>Upload Object CBUFFER to GPU</strong>：将对象常量缓冲区上传到GPU。</li><li><strong>Gather all material data in system memory and fill Material CBUFFER</strong>：在系统内存中收集所有材质数据并填充到材质常量缓冲区（Material CBUFFER）中。</li><li><strong>Upload Material CBUFFER to GPU</strong>：将材质常量缓冲区上传到GPU。</li><li><strong>Bind Material CBUFFER</strong>：绑定材质常量缓冲区。</li><li><strong>Bind Object CBUFFER</strong>：绑定对象常量缓冲区。</li><li><strong>Draw Call</strong>：执行绘制调用。</li><li>**Material break?**：检查是否有材质切换（Material break）。如果有，则返回到第二步重新开始。如果没有，则完成这个批次的绘制调用。</li></ol><h4 id="SRP批处理（SRP-Batch）"><a href="#SRP批处理（SRP-Batch）" class="headerlink" title="SRP批处理（SRP Batch）"></a>SRP批处理（SRP Batch）</h4><ol><li><strong>SetShaderPass（large complete GPU setup）</strong>：开始一个大的完整的GPU设置。</li><li><strong>Bind persistent Material CBUFFER</strong>：绑定持久化的材质常量缓冲区。</li><li><strong>Bind with offset Object data from a large CBUFFER</strong>：从一个大的常量缓冲区中绑定带有偏移量的对象数据。</li><li><strong>Draw Call</strong>：执行绘制调用。</li><li>**Shader Variant break?**：检查是否有Shader变种切换（Shader Variant break）。如果有，则返回到第一步重新开始。如果没有，则完成这个批次的绘制调用。</li></ol><h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><ul><li><strong>数据收集和上传</strong>：标准批处理中，材质和对象数据分别在系统内存中收集并分别上传到GPU。而在SRP批处理中，材质常量缓冲区是持久化的，<u>减少了重复绑定的开销</u>。</li><li><strong>绑定操作</strong>：标准批处理每次绘制调用前都需要绑定材质和对象常量缓冲区，而SRP批处理则<u>通过偏移量绑定大缓冲区中的数据</u>，<u>减少了绑定操作</u>。</li><li><strong>分支条件</strong>：<u>标准批处理在每次材质切换时需要重新开始所有步骤，而SRP批处理在Shader变种切换时才需要重新开始</u>。</li></ul><p>回到场景中，我们自定义的着色器在Inspector面板可以发现其不支持SRP Batcher，因为没有存放到对应的常量缓冲区。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727224118208.png" alt="image-20240727224118208"></p><p>我们修改Shader，对将变量放入常量缓冲区，并且VP矩阵还可用于同一帧中同一台摄像机绘制的所有内容。Unity的着色器利用了这一点，并将矩阵放在不同的常量缓冲区中。VP矩阵放入每帧（per-frame）缓冲区，而M矩阵放入每次绘制（per-draw）缓冲区。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">float4 _BaseColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerDraw)</span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_WorldToObject;</span><br><span class="line">float4 unity_LODFade;</span><br><span class="line">real4 unity_WorldTransformParams;</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure><p>启用 SRP 批处理器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomRenderPipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Draw Call显示，都在一个SRP批次。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727234135147.png" alt="image-20240727234135147"></p><h3 id="多种颜色"><a href="#多种颜色" class="headerlink" title="多种颜色"></a>多种颜色</h3><p>在<u>每种材质的内存布局必须相同的前提</u>下，即使我们使用多种材质，我们也会得到一个批次。因为它们的所有数据都缓存在 GPU 上，并且每个绘制调用只需要包含到正确内存位置的偏移量。</p><p>但如果我们想给每个球体赋予自己的颜色，那么我们就必须创建更多的材料。如果我们可以设置每个对象的颜色，那就更方便了。默认情况下，这是不可能的，但我们可以通过创建自定义组件类型来支持它。</p><p>这个想法是，<u>游戏对象可以附加一个组件，该组件有一个配置选项，该选项将用于为其设置材质属性。它需要知道着色器属性的标识符，我们可以通过它检索并存储在静态变量中</u>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DisallowMultipleComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PerObjectMaterialProperties</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在使用 Shader 属性时，直接使用字符串名称可能会有一定的性能开销，因为每次使用时都需要进行字符串查找。通过 PropertyToID 方法将属性名转换为整数 ID，可以减少这种开销，提高性能。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> baseColorId = Shader.PropertyToID(<span class="string">&quot;_BaseColor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Color baseColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MaterialPropertyBlock block;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnValidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            block = <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        block.SetColor(baseColorId, baseColor);</span><br><span class="line">        GetComponent&lt;Renderer&gt;().SetPropertyBlock(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们给每个球体分别附上PerObjectMaterialProperties组件，并分别设置颜色，可以发现SRP Batcher无法处理每个对象的材质属性，现在退回到每个球体调用一个Draw Call。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240728001622655.png" alt="image-20240728001622655"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;Unity-SRP-02-着色器和批处理&quot;&gt;&lt;a href=&quot;#Unity-SRP-02-着色器和批处理&quot; class=&quot;headerlink&quot; title=&quot;Unity SRP 02-着色器和批处理&quot;&gt;&lt;/a&gt;Unity SRP 02-着色器和批处理&lt;</summary>
      
    
    
    
    <category term="Unity SRP" scheme="http://example.com/categories/Unity-SRP/"/>
    
    
    <category term="游戏渲染" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity SRP 01-自定义管线</title>
    <link href="http://example.com/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/"/>
    <id>http://example.com/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/</id>
    <published>2024-07-25T02:19:02.000Z</published>
    <updated>2024-07-26T15:32:45.919Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-01-自定义管线"><a href="#Unity-SRP-01-自定义管线" class="headerlink" title="Unity SRP 01-自定义管线"></a>Unity SRP 01-自定义管线</h1><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>为了渲染任何东西，必须确定必须绘制哪些形状，在何处、何时以及使用什么设置。这可能会变得非常复杂，具体取决于涉及多少效果。灯光、阴影、透明度、图像效果、体积效果等都必须按照正确的顺序进行处理，才能得到最终图像。这就是渲染管线的作用。</p><p>过去，Unity 仅支持几种内置的渲染方式（Build-in RP）。Unity2018添加了两个使用这种新方法制作的实验性 RP：<u>Lightweight RP and the High Definition RP</u>。在 Unity 2019 中，轻量级 RP 不再是实验性的，而是在 Unity 2019.3 中更名为<u>URP</u>。</p><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>在Unity 2022.3.12f1中创建新的3D项目，并且在场景中放置若干球体，并分别赋予不同材质：</p><ol><li>Unlit&#x2F;Color 黄色</li><li>Unlit&#x2F;Transparent 白色</li><li>Standard（RenderMode:Opaque） 红色</li><li>Standard（RenderMode:Transparent） 蓝色</li></ol><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726172826097.png" alt="image-20240726172826097" title="测试场景"><h3 id="管道资产"><a href="#管道资产" class="headerlink" title="管道资产"></a>管道资产</h3><p>管道资产是为 Unity 提供一种方法来获取负责渲染的管道对象实例。资产本身只是一个句柄和存储设置的地方。</p><p>这里创建一个C#脚本，创建一个新的类CustomRenderPipelineAsset，继承RenderPipelineAsset。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CreateAssetMenu可以让这个类成为一种类型的资产，从编辑器菜单栏快捷创建</span></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Rendering/Custom Render Pipeline&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//放回自定义的渲染管线实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在新建菜单项中新建一个RenderPipelineAsset，并在项目设置中选择它</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726174100845.png" alt="image-20240726174100845" title="新建渲染管线资产并设定"></p><h3 id="渲染管线实例"><a href="#渲染管线实例" class="headerlink" title="渲染管线实例"></a>渲染管线实例</h3><p>创建一个类CustomRenderPipeline，并继承RenderPipeline。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span> &#123;</span><br><span class="line">    <span class="comment">//RenderPipeline定义了一个受保护的抽象方法，我们必须重写该方法才能创建具体的管道。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, Camera[] cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法是为自定义 SRP 定义的入口点，但由于相机阵列参数需要每帧分配内存，因此引入了一个替代方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>Unity 在 RP 实例上调用的每一帧。它传递一个上下文结构，该结构提供与引擎的连接，我们可以使用它进行渲染。它还传递一组摄像机，因为场景中可能有多个活动摄像机。RP 负责按照提供的顺序渲染所有这些摄像机。</p><h3 id="相机渲染器"><a href="#相机渲染器" class="headerlink" title="相机渲染器"></a>相机渲染器</h3><p>每个摄像机都是独立渲染的。因此，我们不会渲染所有摄像机，而是将该责任转发给专门用于渲染一个摄像机的新类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span> &#123;</span><br><span class="line"></span><br><span class="line">ScriptableRenderContext context;</span><br><span class="line"></span><br><span class="line">Camera camera;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在CustomRenderPipeline中创建一个CameraRenderer实例，使用它在一个循环中渲染所有摄像机。</p><p><em><strong>CustomRenderPipeline</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CameraRenderer renderer = <span class="keyword">new</span> CameraRenderer();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cameras.Count; i++) &#123;</span><br><span class="line">renderer.Render(context, cameras[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制天空盒"><a href="#绘制天空盒" class="headerlink" title="绘制天空盒"></a>绘制天空盒</h3><p>我们首先让CameraRenderer渲染绘制天空盒，这可以通过在上下文中调用相机作为参数来完成。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时天空盒子并没有出现，因为我们<em><strong>向上下文发出的命令是缓冲的</strong></em>，我们必须通过调用上下文来<em><strong>提交命令缓冲区渲染命令</strong></em>的工作以供执行。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给content发出渲染天空盒子命令</span></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">    <span class="comment">//提交命令缓冲区所有命令</span></span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天空盒子就会出现在场景中，在帧调试器中还能看到它的实际绘制调用。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180309775.png" alt="image-20240726180309775" title="绘制天空盒子"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180330757.png" alt="image-20240726180330757" title="帧调试器结果"></p><p>这里虽然提交了天空盒子的渲染指令，但是最终是否绘制取决于场景中相机的Clear Flags</p><hr><h4 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h4><p>相机的 <code>Clear Flags</code> 属性在 Unity 中用于控制每一帧开始时如何清除之前的渲染内容。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182613555.png" alt="image-20240726182613555"></p><p>这里我们在Build-in管线下测试。</p><h5 id="Solid"><a href="#Solid" class="headerlink" title="Solid"></a>Solid</h5><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182833395.png" alt="image-20240726182833395"></p><p>用指定颜色填充的方式清除颜色缓冲区。</p><h5 id="Depth-Only"><a href="#Depth-Only" class="headerlink" title="Depth Only"></a>Depth Only</h5><p>当相机的 <code>Clear Flags</code> 属性设置为 <code>Depth Only</code> 时，相机会在每一帧开始时只清除深度缓冲区，而不会清除颜色缓冲区。这意味着屏幕上的颜色内容会被保留，但深度信息会被重置。<code>Depth Only</code> 清除模式通常用于多个相机的叠加渲染，确保深度信息不混乱。</p><p>常用场景包括：</p><pre><code>1. 多相机渲染，叠加渲染内容1. 后处理效果</code></pre><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184158104.png" alt="image-20240726184158104"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184210525.png" alt="image-20240726184210525"></p><p>这里两个相机渲染结果叠加了。</p><h5 id="Don’t-Clear"><a href="#Don’t-Clear" class="headerlink" title="Don’t Clear"></a>Don’t Clear</h5><p>不清除缓冲区。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184358837.png" alt="image-20240726184358837"></p><p>这里拖动白球位置，在屏幕上会保留上一帧像素值。</p><hr><p>为了正确渲染天空盒和整个场景，我们必须设置视图投影矩阵。此变换矩阵将摄像机的位置和方向（视图矩阵）与摄像机的透视或正交投影（投影矩阵）相结合。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>某些任务（如绘制天空盒）可以通过专用方法发出，但其他命令必须通过单独的命令缓冲区间接发出。我们需要这样一个缓冲区来绘制场景中的其他几何体，因此我们创建一个缓冲区，并用名称来标识它。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> bufferName = <span class="string">&quot;Render Camera&quot;</span>;</span><br><span class="line"></span><br><span class="line">CommandBuffer buffer = <span class="keyword">new</span> CommandBuffer &#123;</span><br><span class="line">name = bufferName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用命令缓冲区来注入分析器样本，这些样本将同时显示在分析器和帧调试器中。这是通过在适当的时间点调用来完成的。</p><p>要执行缓冲区，请在上下文上调用缓冲区作为参数。由于执行和清算始终是一起完成的，因此添加一个同时执行这两项操作的方法非常方便。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样开始</span></span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line">   ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样的结束</span></span><br><span class="line">buffer.EndSample(bufferName);</span><br><span class="line">       ExecuteBuffer();</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteBuffer</span> ()</span> &#123;</span><br><span class="line">context.ExecuteCommandBuffer(buffer);</span><br><span class="line">buffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726200112602.png" alt="image-20240726200112602"></p><h3 id="清除渲染目标"><a href="#清除渲染目标" class="headerlink" title="清除渲染目标"></a>清除渲染目标</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">    buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line"></span><br><span class="line">ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制几何图形"><a href="#绘制几何图形" class="headerlink" title="绘制几何图形"></a>绘制几何图形</h3><p>我们目前看到的是天空盒，但看不到我们在场景中放置的任何物体。我们不是绘制每个对象，而是只渲染那些对相机可见的对象。因此，我们可以提出视锥体之外的对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CullingResults cullingResults;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果剔除失败就中止</span></span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">Cull</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//ScriptableCullingParameters 是一个结构体，包含了剔除操作所需的各种参数。</span></span><br><span class="line"><span class="keyword">if</span> (camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters p)) &#123;</span><br><span class="line">           <span class="comment">//执行剔除操作</span></span><br><span class="line">           cullingResults = context.Cull(<span class="keyword">ref</span> p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦我们知道了什么是可见的，我们就可以继续渲染这些东西。这是通过调用上下文来完成的，将<u>剔除结果</u>作为参数，告诉它使用哪个渲染器。除此之外，我们还必须提供<u>绘图设置和过滤设置</u>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings();</span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings();</span><br><span class="line"></span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还没有看到任何内容，因为我们还必须指示允许哪种类型的着色器通道。因此我们必须获取通道的着色器标签ID。</p><p>我们还可以在自定义着色器中定义自己的<code>LightMode</code>标签。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;MyCustomPass&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;MyCustomPass&quot; &#125;</span><br><span class="line">    <span class="comment">// 着色器代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">private static <span class="keyword">readonly</span> ShaderTagId myCustomPassTag = new ShaderTagId(&quot;MyCustomPass&quot;);</span><br></pre></td></tr></table></figure><p>我们在这里支持Unlit着色器渲染。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SRPDefaultUnlit：用于脚本渲染管线的默认无光照通道</span></span><br><span class="line"><span class="keyword">static</span> ShaderTagId unlitShaderTagId = <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;SRPDefaultUnlit&quot;</span>);</span><br><span class="line"><span class="comment">//-----其他通道-----</span></span><br><span class="line"><span class="comment">//ForwardBase：用于前向渲染路径中的基础通道</span></span><br><span class="line"><span class="comment">//ForwardAdd：用于前向渲染路径中的附加光照通道</span></span><br><span class="line"><span class="comment">//ShadowCaster：用于阴影绘制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//控制渲染绘制顺序</span></span><br><span class="line"><span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera);</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">unlitShaderTagId, sortingSettings</span><br><span class="line">);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指出允许的渲染队列</span></span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br></pre></td></tr></table></figure><p>我们能发现Unlit&#x2F;Transparent材质的物体没有显示，因为这些透明材质没有开启深度写入，在RenderSkyBox时像素值被覆盖了</p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205350966.png" alt="image-20240726205350966" style="zoom:50%;"><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205433116.png" alt="image-20240726205433116" style="zoom:50%;"><h3 id="分别绘制透明和不透明几何图形"><a href="#分别绘制透明和不透明几何图形" class="headerlink" title="分别绘制透明和不透明几何图形"></a>分别绘制透明和不透明几何图形</h3><p>解决方案是先绘制不透明对象，然后绘制天空盒，然后再绘制透明对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    &#123;</span><br><span class="line">        criteria = SortingCriteria.CommonOpaque</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    context.DrawSkybox(camera);</span><br><span class="line"></span><br><span class="line">    sortingSettings.criteria = SortingCriteria.CommonTransparent;</span><br><span class="line">    drawingSettings.sortingSettings = sortingSettings;</span><br><span class="line">    filteringSettings.renderQueueRange = RenderQueueRange.transparent;</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Frame Debugger窗口绘制结果</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726210055545.png" alt="image-20240726210055545"></p><h2 id="编辑器渲染"><a href="#编辑器渲染" class="headerlink" title="编辑器渲染"></a>编辑器渲染</h2><h3 id="绘制传统着色器"><a href="#绘制传统着色器" class="headerlink" title="绘制传统着色器"></a>绘制传统着色器</h3><p>我们如下设置，覆盖所有 Unity 的默认着色器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> ShaderTagId[] legacyShaderTagIds = &#123;</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Always&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;ForwardBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;PrepassBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Vertex&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLMRGBM&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLM&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">);</span><br><span class="line">        <span class="comment">//第2个开始使用SetShaderPassName传递</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; legacyShaderTagIds.Length; i++) &#123;</span><br><span class="line">drawingSettings.SetShaderPassName(i, legacyShaderTagIds[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215013061.png" alt="image-20240726215013061"></p><h3 id="错误材料"><a href="#错误材料" class="headerlink" title="错误材料"></a>错误材料</h3><p>为了清楚地指示哪些对象使用不受支持的着色器，我们将使用 Unity 的错误着色器绘制它们。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errorMaterial == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errorMaterial =</span><br><span class="line">            <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/InternalErrorShader&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">        legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        overrideMaterial = errorMaterial</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215926396.png" alt="image-20240726215926396"></p><h3 id="绘制小工具"><a href="#绘制小工具" class="headerlink" title="绘制小工具"></a>绘制小工具</h3><p>Gizmos应该在其他所有内容之后绘制</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawGizmos</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Handles.ShouldRenderGizmos()) &#123;</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PreImageEffects);</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PostImageEffects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">DrawGizmos();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221445569.png" alt="image-20240726221445569"></p><h3 id="绘制UI"><a href="#绘制UI" class="headerlink" title="绘制UI"></a>绘制UI</h3><p>帧调试器向我们展示了 UI 是单独呈现的，而不是由 RP 呈现的。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221644570.png" alt="image-20240726221644570"></p><p>我们将Canvas组件设置从RenderMode，Screen Space - Overlay【所有图层最上层】变换到Screen Space - Camera，并将其更改为主摄像头并使用主摄像头作为主摄像头，将使其成为透明几何体的一部分。</p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726225812383.png" alt="image-20240726225812383" style="zoom:50%;"><p>如果想要UI显示在场景窗口中，就需要将UI显示添加到世界几何体中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (camera.cameraType == CameraType.SceneView) &#123;</span><br><span class="line">ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为可能会向场景添加几何图形，因此必须在剔除之前完成。</span></span><br><span class="line">   PrepareForSceneWindow();</span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726230354448.png" alt="image-20240726230354448"></p><hr><p><strong>参考文章</strong></p><p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">自定义渲染管线 (catlikecoding.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/165140042">Unity可编程渲染管线（SRP）系列（一）——自定义管线（控制渲染） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;Unity-SRP-01-自定义管线&quot;&gt;&lt;a href=&quot;#Unity-SRP-01-自定义管线&quot; class=&quot;headerlink&quot; title=&quot;Unity SRP 01-自定义管线&quot;&gt;&lt;/a&gt;Unity SRP 01-自定义管线&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    <category term="Unity SRP" scheme="http://example.com/categories/Unity-SRP/"/>
    
    
    <category term="游戏渲染" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Start</title>
    <link href="http://example.com/2024/07/25/Start/"/>
    <id>http://example.com/2024/07/25/Start/</id>
    <published>2024-07-24T16:38:55.000Z</published>
    <updated>2024-07-24T17:13:01.242Z</updated>
    
    <content type="html"><![CDATA[<hr><p>故事从20年夏天的风吹起，我用四年的时光走完了故事序章，一路上我做了很多自己想做的事情，一切都听凭本心。</p><p>内心渴望去探索新知识的同时，却又迷茫着，顾虑着未来。</p><p>电子琴、唱歌、摄影、塔罗、运动、日语…这四年，各种事情我都去学习体会，我想更多的感受世界，但是我不可避免的发现，留给我的时间并不是那么充裕。</p><p>在灵犀互娱游戏引擎岗实习的日子，我愈发觉得自己需要尽早变得成熟可靠，我曾跟老大许下承诺，也是我发自内心的渴望，三年后我希望成为一名独当一面的程序员，我希望自己毕业后还是能在游戏行业工作。</p><p>开这个博客，希望能督促自己好好看书，不要颓废，在接下来的研究生生涯中，不留遗憾，把自己想做的事情全都完成。</p><p>大学四年里，从游戏客户端开发、游戏渲染、游戏引擎开发都有所学习，不过都是一些基础的学习而已，之后博客会围绕更进一步学习展开~</p><p>那么故事的正篇就从这里开始叭~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;故事从20年夏天的风吹起，我用四年的时光走完了故事序章，一路上我做了很多自己想做的事情，一切都听凭本心。&lt;/p&gt;
&lt;p&gt;内心渴望去探索新知识的同时，却又迷茫着，顾虑着未来。&lt;/p&gt;
&lt;p&gt;电子琴、唱歌、摄影、塔罗、运动、日语…这四年，各种事情我都去学习体会，我想更</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
