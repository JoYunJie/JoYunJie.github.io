<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity SRP 03-基础光照</title>
      <link href="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/"/>
      <url>/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-03-基础光照"><a href="#Unity-SRP-03-基础光照" class="headerlink" title="Unity SRP 03-基础光照"></a>Unity SRP 03-基础光照</h1><table><tr><td bgcolor="MintCream">本文重点：<br>    <ul>        <li>使用法向量计算光照</li>        <li>支持多个方向光</li>        <li>应用BRDF</li>        <li>可发光的透明材质</li>        <li>使用预设创建自定义着色器GUI</li>    </ul> </td></tr></table><h2 id="照明"><a href="#照明" class="headerlink" title="照明"></a>照明</h2><h3 id="Lit-Shader"><a href="#Lit-Shader" class="headerlink" title="Lit Shader"></a>Lit Shader</h3><p>将在Unlit Shader基础上修改，并增加Tags标记LightMode为CustomLit，来指示我们自定义照明模式。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">Tags &#123;</span><br><span class="line">&quot;LightMode&quot; = &quot;CustomLit&quot;</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CameraRenderer中添加新的支持的着色器标签标识符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ShaderTagId unlitShaderTagId = <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;SRPDefaultUnlit&quot;</span>),</span><br><span class="line">litShaderTagId = <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;CustomLit&quot;</span>);</span><br><span class="line">...</span><br><span class="line">drawingSettings.SetShaderPassName(<span class="number">1</span>, litShaderTagId);</span><br></pre></td></tr></table></figure><h3 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h3><p>需要注意的是插值三角面片的法向量，会引起向量长度变化。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.rgb = <span class="built_in">abs</span>(<span class="built_in">length</span>(input.normalWS) - <span class="number">1.0</span>) * <span class="number">10.0</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240806180359012.png" alt="image-20240806180359012"></p><p>归一化后</p><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240806180422373.png" alt="image-20240806180422373"></p><h3 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h3><p>着色器中的光照是关于模拟照射到表面的光线之间的交互，这意味着我们必须跟踪表面的属性，我们创建一个Surface.hlsl文件。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_SURFACE_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_SURFACE_INCLUDED</span></span><br><span class="line"></span><br><span class="line">struct Surface &#123;</span><br><span class="line">float3 normal;</span><br><span class="line">float3 color;</span><br><span class="line"><span class="type">float</span> alpha;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="计算光照"><a href="#计算光照" class="headerlink" title="计算光照"></a>计算光照</h3><p>为了计算实际的照明，我们将创建一个函数GetLighting。最初，让它返回表面法线的 Y 分量，我们创建一个Lighting.hlsl</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_LIGHTING_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_LIGHTING_INCLUDED</span></span><br><span class="line"></span><br><span class="line">float3 GetLighting (Surface surface) &#123;</span><br><span class="line"><span class="keyword">return</span> surface.normal.y * surface.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>在LitPass.hlsl中包含（之后创建新文件同理，不再重复）</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Surface.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Lighting.hlsl&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240806205101195.png" alt="image-20240806205101195"></p><h2 id="Lights"><a href="#Lights" class="headerlink" title="Lights"></a>Lights</h2><h3 id="Light-Structure"><a href="#Light-Structure" class="headerlink" title="Light Structure"></a>Light Structure</h3><p>使用一个结构体来存储光照数据，需要包含光颜色和方向，放在Light.hlsl中</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_LIGHT_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_LIGHT_INCLUDED</span></span><br><span class="line"></span><br><span class="line">struct Light &#123;</span><br><span class="line">float3 color;</span><br><span class="line">float3 direction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light GetDirectionalLight () &#123;</span><br><span class="line">Light light;</span><br><span class="line">light.color = <span class="number">1.0</span>;</span><br><span class="line">light.direction = float3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>修改Lighting.hlsl，加上Light的光照强度</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算光照强度</span></span><br><span class="line">float3 IncomingLight (Surface surface, Light light) &#123;</span><br><span class="line"><span class="keyword">return</span> saturate(<span class="built_in">dot</span>(surface.normal, light.direction))* light.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算光照颜色</span></span><br><span class="line">float3 GetLighting (Surface surface, Light light) &#123;</span><br><span class="line"><span class="keyword">return</span> IncomingLight(surface, light) * surface.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 GetLighting (Surface surface) &#123;</span><br><span class="line"><span class="keyword">return</span> GetLighting(surface, GetDirectionalLight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向GPU发送光数据"><a href="#向GPU发送光数据" class="headerlink" title="向GPU发送光数据"></a>向GPU发送光数据</h3><p>为了使光源的数据在着色器中可访问，我们必须为其创建统一的值，就像着色器属性一样，这里我们放在缓冲区CBUFFER中。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CBUFFER_START(_CustomLight)</span><br><span class="line">float3 _DirectionalLightColor;</span><br><span class="line">float3 _DirectionalLightDirection;</span><br><span class="line">CBUFFER_END</span><br><span class="line">    ...</span><br><span class="line">Light GetDirectionalLight () &#123;</span><br><span class="line">Light light;</span><br><span class="line">light.color = _DirectionalLightColor;</span><br><span class="line">light.direction = _DirectionalLightDirection;</span><br><span class="line"><span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的 RP 必须将光数据发送到 GPU。我们将为此创建一个新类Lighting。它的工作原理就像灯一样。给它一个带有上下文参数的公共方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lighting</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> bufferName = <span class="string">&quot;Lighting&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span></span><br><span class="line">dirLightColorId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightColor&quot;</span>),</span><br><span class="line">dirLightDirectionId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightDirection&quot;</span>);</span><br><span class="line"></span><br><span class="line">CommandBuffer buffer = <span class="keyword">new</span> CommandBuffer &#123;</span><br><span class="line">name = bufferName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span> (<span class="params">ScriptableRenderContext context</span>)</span> &#123;</span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line">SetupDirectionalLight();</span><br><span class="line">buffer.EndSample(bufferName);</span><br><span class="line">context.ExecuteCommandBuffer(buffer);</span><br><span class="line">buffer.Clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupDirectionalLight</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">//获取场景中光源信息</span></span><br><span class="line">        Light light = RenderSettings.sun;</span><br><span class="line">        <span class="comment">//设置给缓冲区</span></span><br><span class="line">buffer.SetGlobalVector(dirLightColorId, light.color.linear * light.intensity);</span><br><span class="line">buffer.SetGlobalVector(dirLightDirectionId, -light.transform.forward);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CameraRenderer中加入Lighting的Setup，将上下文传递给Lighting</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lighting lighting = <span class="keyword">new</span> Lighting();</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, Camera camera,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">bool</span> useDynamicBatching, <span class="built_in">bool</span> useGPUInstancing</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">lighting.Setup(context);</span><br><span class="line">DrawVisibleGeometry(useDynamicBatching, useGPUInstancing);</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">DrawGizmos();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将场景方向光设置为红色，可以得到下面结果</p><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240806211801014.png" alt="image-20240806211801014"></p><h3 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h3><p>剔除时，Unity会找出哪些灯光会影响摄像机可见空间，我们可以依赖这些信息来获取场景的光源信息。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CullingResults cullingResults;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, CullingResults cullingResults</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.cullingResults = cullingResults;</span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line"><span class="comment">//SetupDirectionalLight();</span></span><br><span class="line">SetupLights();</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupLights</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//通过剔除结果检索所需的灯光</span></span><br><span class="line">       NativeArray&lt;VisibleLight&gt; visibleLights = cullingResults.visibleLights;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="多方向光源"><a href="#多方向光源" class="headerlink" title="多方向光源"></a>多方向光源</h3><p>支持多个定向光源，但我们必须将所有这些光源的数据发送到GPU，这里使用数组存储多个光源信息，并将光源数量最大值设置为4。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxDirLightCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> dirLightCountId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightCount&quot;</span>),</span><br><span class="line">    dirLightColorsId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightColors&quot;</span>),</span><br><span class="line">    dirLightDirectionsId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightDirections&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Vector4[]</span><br><span class="line">    dirLightColors = <span class="keyword">new</span> Vector4[maxDirLightCount],</span><br><span class="line">    dirLightDirections = <span class="keyword">new</span> Vector4[maxDirLightCount];</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引填充一个特定光源信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupDirectionalLight</span> (<span class="params"><span class="built_in">int</span> index, VisibleLight visibleLight</span>)</span> &#123;</span><br><span class="line">dirLightColors[index] = visibleLight.finalColor;</span><br><span class="line">dirLightDirections[index] = -visibleLight.localToWorldMatrix.GetColumn(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有可见光并调用每个元素，然后在缓冲区上将数据发送到GPU。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有光源并填充光源数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupLights</span>()</span> &#123;</span><br><span class="line">    NativeArray&lt;VisibleLight&gt; visibleLights = cullingResults.visibleLights;</span><br><span class="line">    <span class="built_in">int</span> dirLightCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; visibleLights.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VisibleLight visibleLight = visibleLights[i];</span><br><span class="line">        <span class="comment">//只支持方向光</span></span><br><span class="line">        <span class="keyword">if</span> (visibleLight.lightType == LightType.Directional)</span><br><span class="line">        &#123;</span><br><span class="line">            SetupDirectionalLight(dirLightCount++, <span class="keyword">ref</span> visibleLight);</span><br><span class="line">            <span class="keyword">if</span> (dirLightCount &gt;= maxDirLightCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.SetGlobalInt(dirLightCountId, visibleLights.Length);</span><br><span class="line">    buffer.SetGlobalVectorArray(dirLightColorsId, dirLightColors);</span><br><span class="line">    buffer.SetGlobalVectorArray(dirLightDirectionsId, dirLightDirections);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="着色器循环"><a href="#着色器循环" class="headerlink" title="着色器循环"></a>着色器循环</h3><p>调整缓冲区，使其与新的数据格式匹配。数组在着色器中具有固定大小，无法调整大小。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MAX_DIRECTIONAL_LIGHT_COUNT 4</span></span><br><span class="line"></span><br><span class="line">CBUFFER_START(_CustomLight)</span><br><span class="line"><span class="comment">//float4 _DirectionalLightColor;</span></span><br><span class="line"><span class="comment">//float4 _DirectionalLightDirection;</span></span><br><span class="line"><span class="type">int</span> _DirectionalLightCount;</span><br><span class="line">float4 _DirectionalLightColors[MAX_DIRECTIONAL_LIGHT_COUNT];</span><br><span class="line">float4 _DirectionalLightDirections[MAX_DIRECTIONAL_LIGHT_COUNT];</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float3 GetLighting (Surface surface) &#123;</span><br><span class="line">float3 color = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GetDirectionalLightCount(); i++) &#123;</span><br><span class="line">color += GetLighting(surface, GetDirectionalLight(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240807103221717.png" alt="image-20240807103221717"></p><h3 id="着色器目标级别"><a href="#着色器目标级别" class="headerlink" title="着色器目标级别"></a>着色器目标级别</h3><p>对于着色器来说，具有可变长度的循环曾经是一个问题，但现代 GPU 可以毫无问题地处理它们，尤其是当绘制调用的所有片段都以相同的方式迭代相同的数据时。</p><p>但是，默认情况下，OpenGL ES 2.0 和 WebGL 1.0 图形 API 无法处理此类循环。虽然可以用其他方法完成这项工作，但是会使得代码变得更加复杂，因此通过指令将着色器通道的目标级别提高到 3.5。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#pragma target 3.5</span></span><br><span class="line">…</span><br><span class="line">ENDHLSL</span><br></pre></td></tr></table></figure><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>我们目前正在使用一个非常简单的照明模型，仅适用于完全漫射的表面。我们可以通过应用双向反射分布函数（简称BRDF）来实现更多样化和更逼真的照明。</p><p>原理就不过多介绍了，可以看Games101。</p><h3 id="表面特性"><a href="#表面特性" class="headerlink" title="表面特性"></a>表面特性</h3><p>这里使用金属工作流，需要向着色器添加两个表面属性。</p><p>第一个属性是表面是金属的还是非金属的，其中 1 表示它是完全金属的。默认值为完全电介质。</p><p>第二个属性控制表面的光滑程度，其中 0 表示完全粗糙，1 表示完全光滑。我们将使用 0.5 作为默认值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Metallic (&quot;Metallic&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">_Smoothness (&quot;Smoothness&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>将属性添加到缓冲区</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span><br><span class="line">...</span><br><span class="line">UNITY_DEFINE_INSTANCED_PROP(<span class="type">float</span>, _Metallic)</span><br><span class="line">UNITY_DEFINE_INSTANCED_PROP(<span class="type">float</span>, _Smoothness)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br></pre></td></tr></table></figure><p>我们将金属度和平滑度添加到Surface中</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Surface &#123;</span><br><span class="line">...</span><br><span class="line"><span class="type">float</span> metallic;</span><br><span class="line"><span class="type">float</span> smoothness;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在片元着色器中，设置表面属性</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">surface.metallic = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Metallic);</span><br><span class="line">surface.smoothness =</span><br><span class="line">UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Smoothness);</span><br></pre></td></tr></table></figure><p>在<strong>PerObjectMaterialProperties</strong>中添加对其的支持</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span></span><br><span class="line">baseColorId = Shader.PropertyToID(<span class="string">&quot;_BaseColor&quot;</span>),</span><br><span class="line">cutoffId = Shader.PropertyToID(<span class="string">&quot;_Cutoff&quot;</span>),</span><br><span class="line">metallicId = Shader.PropertyToID(<span class="string">&quot;_Metallic&quot;</span>),</span><br><span class="line">smoothnessId = Shader.PropertyToID(<span class="string">&quot;_Smoothness&quot;</span>);</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField, Range(0f, 1f)</span>]</span><br><span class="line"><span class="built_in">float</span> alphaCutoff = <span class="number">0.5f</span>, metallic = <span class="number">0f</span>, smoothness = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span> ()</span> &#123;</span><br><span class="line">…</span><br><span class="line">block.SetFloat(metallicId, metallic);</span><br><span class="line">block.SetFloat(smoothnessId, smoothness);</span><br><span class="line">GetComponent&lt;Renderer&gt;().SetPropertyBlock(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BRDF属性"><a href="#BRDF属性" class="headerlink" title="BRDF属性"></a>BRDF属性</h3><p>我们单独创建一个BRDF.hlsl文件，来表示多少光从表面反射（漫反射+镜面反射），以及表面的粗糙度。</p><h3 id="反射率"><a href="#反射率" class="headerlink" title="反射率"></a>反射率</h3><p>表面的反射程度各不相同，但一般来说，<u>金属通过镜面反射反射所有光，并且漫反射为零</u>。因此，我们将声明<u>反射率等于金属表面属性</u>。被反射的光不会被漫射，因此我们应该将漫射颜色缩放 1 减去 中的反射率。</p><p>根据能量守恒，出射光不能超过入射光，<u>镜面反射颜色应等于表面颜色减去漫反射颜色。</u></p><h3 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h3><p>粗糙度与光滑度相反，因此我们可以简单地取一减去光滑度。有一个函数PerceptualSmoothnessToPerceptualRoughness可以执行此操作，我们引入CommonMaterial.hlsl</p><h3 id="获取方向"><a href="#获取方向" class="headerlink" title="获取方向"></a>获取方向</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface.viewDirection = <span class="built_in">normalize</span>(_WorldSpaceCameraPos - input.positionWS);</span><br></pre></td></tr></table></figure><h3 id="镜面反射强度"><a href="#镜面反射强度" class="headerlink" title="镜面反射强度"></a>镜面反射强度</h3><p>镜面反射强度公式计算如下</p><script type="math/tex; mode=display">\frac{r^2}{d^2 \max \left(0.1,(L \cdot H)^2\right) n}</script><p>其中$d=(N·H)^2(r^2-1)+1.0001$，L是光线方向，H是L+V归一化向量，n=4r+2是常数项。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_BRDF_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_BRDF_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define MIN_REFLECTIVITY 0.04</span></span><br><span class="line"></span><br><span class="line">struct BRDF &#123;</span><br><span class="line">float3 diffuse;</span><br><span class="line">float3 specular;</span><br><span class="line"><span class="type">float</span> roughness;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将范围从[0,1]变换到[0,0.96]</span></span><br><span class="line"><span class="type">float</span> OneMinusReflectivity (<span class="type">float</span> metallic) &#123;</span><br><span class="line"><span class="type">float</span> range = <span class="number">1.0</span> - MIN_REFLECTIVITY;</span><br><span class="line"><span class="keyword">return</span> range - metallic * range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BRDF GetBRDF (Surface surface) &#123;</span><br><span class="line">BRDF brdf;</span><br><span class="line"><span class="type">float</span> oneMinusReflectivity = OneMinusReflectivity(surface.metallic);</span><br><span class="line">    <span class="comment">//漫反射强度是1-反射率</span></span><br><span class="line">brdf.diffuse = surface.color * oneMinusReflectivity;</span><br><span class="line">    <span class="comment">//金属会影响镜面反射的颜色，而非金属则不会。介电表面的镜面反射颜色应该是白色，我们可以通过使用金属属性在最小反射率0.04和表面颜色之间插值来实现</span></span><br><span class="line">brdf.specular = lerp(MIN_REFLECTIVITY, surface.color, surface.metallic);</span><br><span class="line">    <span class="comment">//光滑度转粗糙度</span></span><br><span class="line"><span class="type">float</span> perceptualRoughness = PerceptualSmoothnessToPerceptualRoughness(surface.smoothness);</span><br><span class="line">brdf.roughness = PerceptualRoughnessToRoughness(perceptualRoughness);</span><br><span class="line"><span class="keyword">return</span> brdf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算镜面反射强度</span></span><br><span class="line"><span class="type">float</span> SpecularStrength (Surface surface, BRDF brdf, Light light) &#123;</span><br><span class="line">float3 h = SafeNormalize(light.direction + surface.viewDirection);</span><br><span class="line"><span class="type">float</span> nh2 = Square(saturate(<span class="built_in">dot</span>(surface.normal, h)));</span><br><span class="line"><span class="type">float</span> lh2 = Square(saturate(<span class="built_in">dot</span>(light.direction, h)));</span><br><span class="line"><span class="type">float</span> r2 = Square(brdf.roughness);</span><br><span class="line"><span class="type">float</span> d2 = Square(nh2 * (r2 - <span class="number">1.0</span>) + <span class="number">1.00001</span>);</span><br><span class="line"><span class="type">float</span> normalization = brdf.roughness * <span class="number">4.0</span> + <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">return</span> r2 / (d2 * <span class="built_in">max</span>(<span class="number">0.1</span>, lh2) * normalization);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回表面的总光照强度（漫反射+镜面反射）</span></span><br><span class="line">float3 DirectBRDF (Surface surface, BRDF brdf, Light light) &#123;</span><br><span class="line"><span class="keyword">return</span> SpecularStrength(surface, brdf, light) * brdf.specular + brdf.diffuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240807151646421.png" alt="image-20240807151646421"></p><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>为了实现类似玻璃的效果，我们需要考虑透明度</p><p>为了引入透明度，我们需要设置混合模式</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">_Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">[Toggle(_CLIPPING)] _Clipping (&quot;Alpha Clipping&quot;, Float) = <span class="number">0</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;Src Blend&quot;, Float) = <span class="number">1</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;Dst Blend&quot;, Float) = <span class="number">0</span></span><br><span class="line">[Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWrite (&quot;Z Write&quot;, Float) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader &#123;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">ZWrite [_ZWrite]</span><br><span class="line"></span><br><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#pragma shader_feature _CLIPPING</span></span><br><span class="line">            ...</span><br><span class="line">ENDHLSL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将漫反射光淡化，并保持镜面反射强度</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brdf.diffuse *= surface.alpha;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240807154553966.png" alt="image-20240807154553966" style="zoom:67%;"></p><p>我们添加一个宏来控制是否将 alpha 与漫反射进行预乘</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BRDF GetBRDF (<span class="keyword">inout</span> Surface surface, <span class="type">bool</span> applyAlphaToDiffuse = <span class="literal">false</span>) &#123;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> (applyAlphaToDiffuse) &#123;</span><br><span class="line">brdf.diffuse *= surface.alpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Toggle(_PREMULTIPLY_ALPHA)] _PremulAlpha (&quot;Premultiply Alpha&quot;, Float) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#pragma shader_feature _PREMULTIPLY_ALPHA</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#if defined(_PREMULTIPLY_ALPHA)</span></span><br><span class="line">BRDF brdf = GetBRDF(surface, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">BRDF brdf = GetBRDF(surface);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="着色器GUI"><a href="#着色器GUI" class="headerlink" title="着色器GUI"></a>着色器GUI</h3><p>自定义着色器GUI，在着色器底部添加一个语句</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom RP/Lit&quot; &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">CustomEditor &quot;CustomShaderGUI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个CustomShaderGUI类，继承ShaderGUI，重写OnGUI方法。</p><p>并且创建三个属性，第一个是材质编辑器，它是负责显示和编辑材质的底层编辑器对象。第二个是<u>对正在编辑的材料的引用</u>，我们可以通过编辑器的属性来检索。它被定义为一个数组，因为它是通用类的一个属性。第三是可以编辑的属性数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomShaderGUI</span> : <span class="title">ShaderGUI</span></span><br><span class="line">&#123;</span><br><span class="line">    MaterialEditor editor;</span><br><span class="line">    Object[] materials;</span><br><span class="line">    MaterialProperty[] properties;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> showPresets;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        MaterialEditor materialEditor, MaterialProperty[] properties</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnGUI(materialEditor, properties);</span><br><span class="line">        editor = materialEditor;</span><br><span class="line">        materials = materialEditor.targets;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置属性，需要在属性数组中找到它，关键字同理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">SetProperty</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaterialProperty property = FindProperty(name, properties, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (property != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        property.floatValue = <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetKeyword</span>(<span class="params"><span class="built_in">string</span> keyword, <span class="built_in">bool</span> enabled</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Material m <span class="keyword">in</span> materials)</span><br><span class="line">        &#123;</span><br><span class="line">            m.EnableKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Material m <span class="keyword">in</span> materials)</span><br><span class="line">        &#123;</span><br><span class="line">            m.DisableKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetProperty</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> keyword, <span class="built_in">bool</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SetProperty(name, <span class="keyword">value</span> ? <span class="number">1f</span> : <span class="number">0f</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        SetKeyword(keyword, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将控制的属性设置setter属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> Clipping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="string">&quot;_Clipping&quot;</span>, <span class="string">&quot;_CLIPPING&quot;</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> PremultiplyAlpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="string">&quot;_PremulAlpha&quot;</span>, <span class="string">&quot;_PREMULTIPLY_ALPHA&quot;</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlendMode SrcBlend</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="string">&quot;_SrcBlend&quot;</span>, (<span class="built_in">float</span>)<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlendMode DstBlend</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="string">&quot;_DstBlend&quot;</span>, (<span class="built_in">float</span>)<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> ZWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="string">&quot;_ZWrite&quot;</span>, <span class="keyword">value</span> ? <span class="number">1f</span> : <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预设按钮"><a href="#预设按钮" class="headerlink" title="预设按钮"></a>预设按钮</h3><p>通过GUI Layout.Button创建一个按钮，并为其命名。如果该方法返回，表示已经被按下。同时我们向编辑器注册一个撤消步骤，调用editor.RegisterPropertyChangeUndo来实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">PresetButton</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (GUILayout.Button(name))</span><br><span class="line">    &#123;</span><br><span class="line">        editor.RegisterPropertyChangeUndo(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpaquePreset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PresetButton(<span class="string">&quot;Opaque&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Clipping = <span class="literal">false</span>;</span><br><span class="line">        PremultiplyAlpha = <span class="literal">false</span>;</span><br><span class="line">        SrcBlend = BlendMode.One;</span><br><span class="line">        DstBlend = BlendMode.Zero;</span><br><span class="line">        ZWrite = <span class="literal">true</span>;</span><br><span class="line">        RenderQueue = RenderQueue.Geometry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClipPreset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PresetButton(<span class="string">&quot;Clip&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Clipping = <span class="literal">true</span>;</span><br><span class="line">        PremultiplyAlpha = <span class="literal">false</span>;</span><br><span class="line">        SrcBlend = BlendMode.One;</span><br><span class="line">        DstBlend = BlendMode.Zero;</span><br><span class="line">        ZWrite = <span class="literal">true</span>;</span><br><span class="line">        RenderQueue = RenderQueue.AlphaTest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FadePreset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PresetButton(<span class="string">&quot;Fade&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Clipping = <span class="literal">false</span>;</span><br><span class="line">        PremultiplyAlpha = <span class="literal">false</span>;</span><br><span class="line">        SrcBlend = BlendMode.SrcAlpha;</span><br><span class="line">        DstBlend = BlendMode.OneMinusSrcAlpha;</span><br><span class="line">        ZWrite = <span class="literal">false</span>;</span><br><span class="line">        RenderQueue = RenderQueue.Transparent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransparentPreset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HasPremultiplyAlpha &amp;&amp; PresetButton(<span class="string">&quot;Transparent&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Clipping = <span class="literal">false</span>;</span><br><span class="line">        PremultiplyAlpha = <span class="literal">true</span>;</span><br><span class="line">        SrcBlend = BlendMode.One;</span><br><span class="line">        DstBlend = BlendMode.OneMinusSrcAlpha;</span><br><span class="line">        ZWrite = <span class="literal">false</span>;</span><br><span class="line">        RenderQueue = RenderQueue.Transparent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在OnGUI方法中调用预设方法，使其显示在编辑器中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">MaterialEditor materialEditor, MaterialProperty[] properties</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">OpaquePreset();</span><br><span class="line">ClipPreset();</span><br><span class="line">FadePreset();</span><br><span class="line">TransparentPreset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/05/Unity-SRP-03-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20240807205958865.png" alt="image-20240807205958865" style="zoom:67%;"></p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>考虑到部分材质没有如上属性，会报错，在SetProperty时我们需要通过查找属性来规避该问题，因为比较简单，详情见参考文章，这里不再赘述。</p><hr><p><strong>参考文章</strong></p><p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/directional-lights/">平行光 (catlikecoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity SRP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合批及GPU实例化</title>
      <link href="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
      <url>/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="合批及GPU实例化"><a href="#合批及GPU实例化" class="headerlink" title="合批及GPU实例化"></a>合批及GPU实例化</h1><table><tr><td bgcolor="MintCream">本文重点：<br>    <ul>        <li>静态批处理</li>        <li>动态批处理</li>        <li>SRP Batcher</li>        <li>GPU Instancing</li>    </ul> </td></tr></table><h2 id="批量渲染"><a href="#批量渲染" class="headerlink" title="批量渲染"></a>批量渲染</h2><p>一般被叫做”合批“。</p><p>批量渲染是通过减少CPU向GPU <strong>发送渲染命令（DrawCall）的次数，以及减少GPU切换渲染状态的次数</strong>，尽量让GPU一次多做一些事情，来提升逻辑线和渲染线的整体效率。</p><h3 id="Draw-Call性能消耗原因"><a href="#Draw-Call性能消耗原因" class="headerlink" title="Draw Call性能消耗原因"></a>Draw Call性能消耗原因</h3><p>应用中每次渲染，API调用都会经过”Application -&gt; Runtime -&gt; Driver -&gt; GPU “ 的过程。<strong>Runtime (运行时环境)</strong>负责解释和执行应用层调用的图形指令，Runtime 会将这些高层次的绘制调用转化为底层的图形指令，并进行必要的管理工作，比如状态设置、资源管理等。</p><p>其中Draw Call性能消耗原因是，命令从Runtime到Driver的过程中，操作系统要发生<u>用户模式到内核模式的切换</u>，而模式切换对CPU来说是意见非常耗时的工作。</p><p>Runtime中的<u>Command Buffer可以将一些没有必要马上发送给Driver的命令缓冲起来</u>，在适当的时机<u>一起发送给Driver</u>，进而在显卡执行。以这样的方式来寻求最少的CPU模式切换，提升效率。</p><h3 id="合批技术又分为离线合批和实时合批"><a href="#合批技术又分为离线合批和实时合批" class="headerlink" title="合批技术又分为离线合批和实时合批"></a>合批技术又分为离线合批和实时合批</h3><p>离线合批就是在游戏运行前，把相关资源合批处理，减轻引擎实时渲染的负担。</p><p>下面要讲的就是实时合批。</p><h2 id="静态批处理"><a href="#静态批处理" class="headerlink" title="静态批处理"></a>静态批处理</h2><p>表明为Static的静态物体，在使用相同材质球的前提下，在Build项目打包时，Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。</p><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240728141519184.png" alt="image-20240728141519184"></p><p>在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型。</p><p>Static batching并<strong>不减少Draw call的数量</strong></p><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ol><li>共享相同材质、运行时不能改变Transform</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>用空间换时间，提升了渲染效率。</p><p>由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在<u>运行时cpu不需要再次执行顶点变换操作</u>，节约了少量的计算资源；并且这些子模型<u>共享材质，所以在多次Draw call调用之间并没有渲染状态</u>的切换（不需要重新绑定顶点数据、索引数据、指定当前使用的着色器等）</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>打包之后体积增大，<u>应用运行时所占用的内存体积也会增大</u>，需要额外内存存储合并的几何体。</p><p>【在很多不同的GameObject引用同一模型的情况下，不开启Static batching，GameObject共享的模型会在应用程序包内或者内存中<u>只存在一份</u>，绘制的时候提交模型顶点信息，然后设置每一个GameObjec的材质信息，分别调用渲染API绘制；开启Static batching，在Unity执行Build的时候，场景中<u>所有引用相同模型的GameObject都必须将模型顶点信息复制</u>，并经过计算变化到最终在世界空间中，<u>存储在最终生成的Vertex buffer中</u>。这就导致了打包的体积及运行时内存的占用增大。】</p></li><li><p>静态合批在大多数平台上的限制是64k顶点和64k索引</p></li></ol><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/static.png" alt="img"></p><h3 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a>动态批处理</h3><p>在使用<strong>相同材质球</strong>的情况下，Unity会在运行时对于<strong>正在视野中</strong>的符合条件的<u>动态对象</u>在一个Draw call内绘制，所以<strong>会降低Draw Calls</strong>的数量。</p><p>Dynamic batching的原理也很简单，在进行场景绘制之前将<u>所有的共享同一材质的模型的顶点信息变换到世界空间</u>中，然后通过一次Draw call绘制多个模型，达到合批的目的。模型顶点变换的操作是由CPU完成的，所以这会带来一些CPU的性能消耗。并且计算的模型顶点数量不宜太多，否则CPU串行计算耗费的时间太长会造成场景渲染卡顿，所以Dynamic batching只能<u>处理一些小模型</u>。</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ol><li>900个顶点以下的模型。</li><li>如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。</li><li>如果两个模型<strong>缩放大小不同，不能被合批的</strong>，即模型之间的缩放必须一致。</li><li><strong>使用多个pass的Shader不会被合批</strong></li><li>材质球实例必须相同，<strong>每个物体材质球属性必须一致</strong></li></ol><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/dy.png" alt="image-20240728152336622"></p><h3 id="GPU-Instancing"><a href="#GPU-Instancing" class="headerlink" title="GPU Instancing"></a>GPU Instancing</h3><p>对使用<strong>相同材质、相同网格</strong>的物体，对视野中符合要求的所有对象使用Constant Buffer（CBuffer）将信息保存在显存的”常量缓冲区“中，然后从中抽取一个对象作为实例送入渲染流程。</p><p>当在执行DrawCall操作后，从显存中取出实例的部分共享信息与从GPU常量缓冲器中取出对应对象（通过数组索引快速获取）的相关信息一并传递到下一渲染阶段</p><h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><p>碍于缓存区的大小限制，每一个Constant Buffer的大小要严格限制（不得大于64k）</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><p>合批的物体，相对动态批处理，允许使用统一材质且对应的材质属性（材质属性结构需要保持一致）</p><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240728153406766.png" alt="image-20240728153406766"></p><h3 id="SRP-Batcher"><a href="#SRP-Batcher" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h3><p>在使用LWRP或者HWRP时，开启SRP Batcher的情况下，只要物体的<strong>Shader中变体</strong>一致，就可以启用SRP Batcher加速。</p><p>与GPU Instancing原理相似，不同的是<strong><u>因为不用重新创建Constant Buffer[每次只需要在Buffer上进行更新和添加]，所以本质上SRP Batcher不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本</u></strong></p><h4 id="限制-2"><a href="#限制-2" class="headerlink" title="限制"></a>限制</h4><p>Shader变体不同无法合并，比如同一个Shader创建的材质，但是材质选项不同</p><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240727223106405.png" alt="image-srp2"></p><p><img src="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/srp.png" alt="image-srp"></p><hr><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/chqj_163/article/details/117191293">【Unity游戏开发】静态、动态合批与GPU Instancing-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/98642798">关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析 - 知乎 (zhihu.com)</a></p><hr><p><strong>待学习</strong></p><p><a href="https://zhuanlan.zhihu.com/p/34499251">U3D优化批处理-GPU Instancing了解一下 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 渲染基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity SRP 02-绘制调用</title>
      <link href="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/"/>
      <url>/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-02-着色器和批处理"><a href="#Unity-SRP-02-着色器和批处理" class="headerlink" title="Unity SRP 02-着色器和批处理"></a>Unity SRP 02-着色器和批处理</h1><table><tr><td bgcolor="MintCream">本文重点：<br>    <ul>        <li>HLSL着色器</li>        <li>常量缓冲区</li>        <li>支持动态批处理和GPU Instancing</li>    </ul> </td></tr></table><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>创建一个新Unlit Shader。</p><p>【之前看完了《Unity Shader入门精要》，CG语言相对掌握掌握熟练一点，这里跟着教程用HLSL编写着色器】</p><p><strong><em>Unlit.shader</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader&quot;Custom RP/Unlit&quot; &#123;</span><br><span class="line"></span><br><span class="line">Properties &#123;&#125;</span><br><span class="line"></span><br><span class="line">SubShader &#123;</span><br><span class="line"></span><br><span class="line">Pass &#123;</span><br><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex UnlitPassVertex</span></span><br><span class="line"><span class="meta">#pragma fragment UnlitPassFragment</span></span><br><span class="line"><span class="meta">#include &quot;UnlitPass.hlsl&quot;</span></span><br><span class="line">ENDHLSL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>UnlitPass.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止重复定义</span></span><br><span class="line"><span class="meta">#ifndef CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里定义顶点、片元着色器</span></span><br><span class="line">float4 UnlitPassVertex(float3 positionOS : POSITION) : SV_POSITION &#123;</span><br><span class="line">float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line"><span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment() : SV_TARGET &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><strong><em>Common.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float3 TransformObjectToWorld(float3 positionOS) &#123;</span><br><span class="line"><span class="keyword">return</span> mul(unity_ObjectToWorld, float4(positionOS, <span class="number">1.0</span>)).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 TransformWorldToHClip(float3 positionWS) &#123;</span><br><span class="line"><span class="keyword">return</span> mul(unity_MatrixVP, float4(positionWS, <span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><strong><em>UnityInput.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"></span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_MatrixVP;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727175808765.png" alt="image-20240727175808765" style="zoom:67%;"></p><h3 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h3><p>核心库中定义了更多有用的东西，包括各种变换矩阵、光源信息等。</p><p>在Common.hlsl中我们定义常用的方法，这里包括空间转换。</p><p><strong><em>Common.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_COMMON_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Common.hlsl包含了基本数据类型的定义、常用函数等</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"><span class="meta">#include &quot;UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要定义这些矩阵，才能编译</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_M unity_ObjectToWorld</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_M unity_WorldToObject</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_V unity_MatrixV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_V unity_MatrixInvV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_VP unity_MatrixVP</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_M unity_prev_MatrixM</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_I_M unity_prev_MatrixIM</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_P glstate_matrix_projection</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Packages\com.unity.render-pipelines.core\ShaderLibrary\SpaceTransforms.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727211225198.png" alt="image-20240727211225198" style="zoom:67%;"></p><p><strong><em>UnlitPass.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;../ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float4 UnlitPassVertex (float3 positionOS : POSITION) : SV_POSITION &#123;</span><br><span class="line">float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line"><span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment () : SV_TARGET &#123;</span><br><span class="line">    <span class="comment">//颜色输出黄色</span></span><br><span class="line"><span class="keyword">return</span> float4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><strong><em>UnityInput.hlsl</em></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"><span class="meta">#define CUSTOM_UNITY_INPUT_INCLUDED</span></span><br><span class="line"></span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_WorldToObject;</span><br><span class="line">real4 unity_WorldTransformParams;</span><br><span class="line"></span><br><span class="line">float4x4 unity_MatrixVP;</span><br><span class="line">float4x4 unity_MatrixV;</span><br><span class="line">float4x4 unity_MatrixInvV;</span><br><span class="line">float4x4 unity_prev_MatrixM;</span><br><span class="line">float4x4 unity_prev_MatrixIM;</span><br><span class="line">float4x4 glstate_matrix_projection;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727212220987.png" alt="image-20240727212220987" style="zoom:80%;"></p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h3><p>每次Draw Call都需要CPU和GPU通信。如果必须将大量数据发送到 GPU，那么它最终可能会因等待而浪费时间。当 CPU 忙于发送数据时，它无法执行其他操作。这两个问题都会降低帧速率。</p><p>如果每个对象都有自己的绘制调用，这无疑会造成巨大开销。</p><p>这里复制刚刚我们自己创建的材质，制作一个包含16个球体的场景，Game窗口的State Panel统计信息如下。它显示了18个批次，其中1次用于天空盒，1次用于清除渲染目标。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727214343134.png" alt="image-20240727214343134" style="zoom:80%;"></p><h3 id="SRP批处理"><a href="#SRP批处理" class="headerlink" title="SRP批处理"></a>SRP批处理</h3><p>批处理是合并绘制调用的过程，可减少 CPU 和 GPU 之间通信所花费的时间。执行此操作的最简单方法是启用 SRP 批处理器。但是，这仅适用于兼容的着色器，而我们刚刚自定义的着色器则不可以。</p><p>SRP 批处理不会减少绘制调用的数量，而是使它们更精简。它在 GPU 上<u>缓存材质属性</u>，因此不必在每次绘制调用时都发送它们。这既减少了必须通信的数据量，也减少了 CPU 每次绘制调用必须执行的工作。</p><p>但是，仅当着色器<u>遵循统一数据的严格结构时</u>，这才有效。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727223909700.png" alt="image-20240727223909700"></p><p>在此处，CPU 仅处理上图中标记为 <em>Per Object large buffer</em> 的 Unity 引擎属性。所有材质在 GPU 内存中都有持久的 CBUFFER，可供随时使用。这样会加快渲染速度，原因是： 现在，所有材质内容都持久保留在 GPU 内存中。 专用代码针对所有每对象属性，管理着一个大型的每对象 GPU CBUFFER。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727223106405.png" alt="image-20240727223106405"></p><p>这张图展示了在Unity渲染过程中，使用标准批处理（Standard Batch）和SRP批处理（SRP Batch）时，进行绘制调用（Draw Call）时的不同步骤。</p><h4 id="标准批处理（Standard-Batch）"><a href="#标准批处理（Standard-Batch）" class="headerlink" title="标准批处理（Standard Batch）"></a>标准批处理（Standard Batch）</h4><ol><li><strong>SetShaderPass（large complete GPU setup）</strong>：开始一个大的完整的GPU设置。</li><li><strong>Gather all built-in data in system memory and fill Object CBUFFER</strong>：在系统内存中收集所有内置数据并填充到对象常量缓冲区（Object CBUFFER）中。</li><li><strong>Upload Object CBUFFER to GPU</strong>：将对象常量缓冲区上传到GPU。</li><li><strong>Gather all material data in system memory and fill Material CBUFFER</strong>：在系统内存中收集所有材质数据并填充到材质常量缓冲区（Material CBUFFER）中。</li><li><strong>Upload Material CBUFFER to GPU</strong>：将材质常量缓冲区上传到GPU。</li><li><strong>Bind Material CBUFFER</strong>：绑定材质常量缓冲区。</li><li><strong>Bind Object CBUFFER</strong>：绑定对象常量缓冲区。</li><li><strong>Draw Call</strong>：执行绘制调用。</li><li><strong>Material break?</strong>：检查是否有材质切换（Material break）。如果有，则返回到第二步重新开始。如果没有，则完成这个批次的绘制调用。</li></ol><h4 id="SRP批处理（SRP-Batch）"><a href="#SRP批处理（SRP-Batch）" class="headerlink" title="SRP批处理（SRP Batch）"></a>SRP批处理（SRP Batch）</h4><ol><li><strong>SetShaderPass（large complete GPU setup）</strong>：开始一个大的完整的GPU设置。</li><li><strong>Bind persistent Material CBUFFER</strong>：绑定持久化的材质常量缓冲区。</li><li><strong>Bind with offset Object data from a large CBUFFER</strong>：从一个大的常量缓冲区中绑定带有偏移量的对象数据。</li><li><strong>Draw Call</strong>：执行绘制调用。</li><li><strong>Shader Variant break?</strong>：检查是否有Shader变种切换（Shader Variant break）。如果有，则返回到第一步重新开始。如果没有，则完成这个批次的绘制调用。</li></ol><h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><ul><li><strong>数据收集和上传</strong>：标准批处理中，材质和对象数据分别在系统内存中收集并分别上传到GPU。而在SRP批处理中，材质常量缓冲区是持久化的，<u>减少了重复绑定的开销</u>。</li><li><strong>绑定操作</strong>：标准批处理每次绘制调用前都需要绑定材质和对象常量缓冲区，而SRP批处理则<u>通过偏移量绑定大缓冲区中的数据</u>，<u>减少了绑定操作</u>。</li><li><strong>分支条件</strong>：<u>标准批处理在每次材质切换时需要重新开始所有步骤，而SRP批处理在Shader变种切换时才需要重新开始</u>。</li></ul><p>回到场景中，我们自定义的着色器在Inspector面板可以发现其不支持SRP Batcher，因为没有存放到对应的常量缓冲区。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727224118208.png" alt="image-20240727224118208"></p><p>我们修改Shader，对将变量放入常量缓冲区，并且VP矩阵还可用于同一帧中同一台摄像机绘制的所有内容。Unity的着色器利用了这一点，并将矩阵放在不同的常量缓冲区中。VP矩阵放入每帧（per-frame）缓冲区，而M矩阵放入每次绘制（per-draw）缓冲区。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">float4 _BaseColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerDraw)</span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_WorldToObject;</span><br><span class="line">float4 unity_LODFade;</span><br><span class="line">real4 unity_WorldTransformParams;</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure><p>启用 SRP 批处理器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomRenderPipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Draw Call显示，都在一个SRP批次。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240727234135147.png" alt="image-20240727234135147"></p><h3 id="多种颜色"><a href="#多种颜色" class="headerlink" title="多种颜色"></a>多种颜色</h3><p>在<u>每种材质的内存布局必须相同的前提</u>下，即使我们使用多种材质，我们也会得到一个批次。因为它们的所有数据都缓存在 GPU 上，并且每个绘制调用只需要包含到正确内存位置的偏移量。</p><p>但如果我们想给每个球体赋予自己的颜色，那么我们就必须创建更多的材料。如果我们可以设置每个对象的颜色，那就更方便了。默认情况下，这是不可能的，但我们可以通过创建自定义组件类型来支持它。</p><p>这个想法是，<u>游戏对象可以附加一个组件，该组件有一个配置选项，该选项将用于为其设置材质属性。它需要知道着色器属性的标识符，我们可以通过它检索并存储在静态变量中</u>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DisallowMultipleComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PerObjectMaterialProperties</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在使用 Shader 属性时，直接使用字符串名称可能会有一定的性能开销，因为每次使用时都需要进行字符串查找。通过 PropertyToID 方法将属性名转换为整数 ID，可以减少这种开销，提高性能。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> baseColorId = Shader.PropertyToID(<span class="string">&quot;_BaseColor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Color baseColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MaterialPropertyBlock block;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnValidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            block = <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        block.SetColor(baseColorId, baseColor);</span><br><span class="line">        GetComponent&lt;Renderer&gt;().SetPropertyBlock(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们给每个球体分别附上PerObjectMaterialProperties组件，并分别设置颜色，可以发现SRP Batcher无法处理每个对象的材质属性，现在退回到每个球体调用一个Draw Call。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240728001622655.png" alt="image-20240728001622655"></p><h3 id="GPU-Instancing"><a href="#GPU-Instancing" class="headerlink" title="GPU Instancing"></a>GPU Instancing</h3><p>还有另一种方法可以合并绘制调用，该方法适用于每个对象的材质属性。它被称为 GPU 实例化，其工作原理是一次对具有相同网格的多个对象发出一次绘制调用。CPU 收集所有每个对象的转换和材料属性，并将它们放入数组中，然后发送到 GPU。然后，GPU 遍历所有条目，并按照它们提供的顺序呈现它们。</p><p>由于 GPU 实例需要通过数组提供数据，因此我们的着色器目前不支持它。完成此任务的第一步是在顶点上方添加指令，并在着色器的块中分割编译指示。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile_instancing</span></span><br></pre></td></tr></table></figure><p>这个指令使得生成两种着色器变体，一种支持GPU Instancing，一种不支持。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240728113735670.png" alt="image-20240728113735670"></p><p>然后我们需要重新定义我们输入输出的结构，为了访问实例化数据数组，我们需要知道当前渲染对象索引。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加库文件</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//CBUFFER_START(UnityPerMaterial)</span></span><br><span class="line"><span class="comment">//float4 _BaseColor;</span></span><br><span class="line"><span class="comment">//CBUFFER_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变更常量缓冲区定义方式</span></span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span><br><span class="line">UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将输入定义为结构体</span></span><br><span class="line">struct Attributes &#123;</span><br><span class="line">float3 positionOS : POSITION;</span><br><span class="line">    <span class="comment">//存入索引</span></span><br><span class="line">UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Varyings &#123;</span><br><span class="line">float4 positionCS : SV_POSITION;</span><br><span class="line">UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings UnlitPassVertex (Attributes input) &#123;</span><br><span class="line">Varyings output;</span><br><span class="line">    <span class="comment">//从输入中提取索引，并将其存储在其他实例化宏所依赖的全局静态变量</span></span><br><span class="line">UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line">UNITY_TRANSFER_INSTANCE_ID(input, output);</span><br><span class="line">float3 positionWS = TransformObjectToWorld(input.positionOS);</span><br><span class="line">output.positionCS = TransformWorldToHClip(positionWS);</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment (Varyings input) : SV_TARGET &#123;</span><br><span class="line">UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line"><span class="keyword">return</span> UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现GPU实例化适用于共享系统材质对象，允许他们在单个批次中绘制。这里使用了三个材质，因此有三个批次。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240728113337156.png" alt="image-20240728113337156"></p><h3 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a>动态批处理</h3><p>动态批处理，将共享相同材料的多个小网格组合成一个更大的网格，然后被绘制出来。当使用每个对象的材料属性时，这也不起作用。</p><p>同时动态批对对象的顶点数有限制，过大的对象无法进行动态批处理。</p><p>开始动态批处理，我们需要在DrawingSetting中设置。同时由于SRP Batcher优先级高于动态批处理，这里关闭SRP Batcher。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings)</span><br><span class="line">&#123;</span><br><span class="line">    enableDynamicBatching = <span class="literal">true</span>,</span><br><span class="line">    enableInstancing = <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomRenderPipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，GPU实例化比动态批处理工作得更好。</p><p>该方法也有一些注意事项，例如，当涉及不同的尺度时，<u>较大网格的法向量不能保证是单位长度的</u>。此外，<u>绘制顺序改变</u>，因为它现在是一个网格而不是多个。</p><p><img src="/2024/07/27/Unity-SRP-02-%E7%BB%98%E5%88%B6%E8%B0%83%E7%94%A8/image-20240728122413492.png" alt="image-20240728122413492"></p><hr><p><strong>下面这篇文章再说明各种合批技术的特点和区别：</strong></p><a href="/2024/07/28/%E5%90%88%E6%89%B9%E5%8F%8AGPU%E5%AE%9E%E4%BE%8B%E5%8C%96/" title="合批及GPU实例化">合批及GPU实例化</a><hr><p><strong>参考文章</strong></p><p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/draw-calls/">绘制调用 (catlikecoding.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/166334724">Unity可编程渲染管线（SRP）系列（二）——自定义着色器（HLSL和核心库） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity SRP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity SRP 01-自定义管线</title>
      <link href="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/"/>
      <url>/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-01-自定义管线"><a href="#Unity-SRP-01-自定义管线" class="headerlink" title="Unity SRP 01-自定义管线"></a>Unity SRP 01-自定义管线</h1><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>为了渲染任何东西，必须确定必须绘制哪些形状，在何处、何时以及使用什么设置。这可能会变得非常复杂，具体取决于涉及多少效果。灯光、阴影、透明度、图像效果、体积效果等都必须按照正确的顺序进行处理，才能得到最终图像。这就是渲染管线的作用。</p><p>过去，Unity 仅支持几种内置的渲染方式（Build-in RP）。Unity2018添加了两个使用这种新方法制作的实验性 RP：<u>Lightweight RP and the High Definition RP</u>。在 Unity 2019 中，轻量级 RP 不再是实验性的，而是在 Unity 2019.3 中更名为<u>URP</u>。</p><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>在Unity 2022.3.12f1中创建新的3D项目，并且在场景中放置若干球体，并分别赋予不同材质：</p><ol><li>Unlit/Color 黄色</li><li>Unlit/Transparent 白色</li><li>Standard（RenderMode:Opaque） 红色</li><li>Standard（RenderMode:Transparent） 蓝色</li></ol><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726172826097.png" alt="image-20240726172826097" title="测试场景"></p><h3 id="管道资产"><a href="#管道资产" class="headerlink" title="管道资产"></a>管道资产</h3><p>管道资产是为 Unity 提供一种方法来获取负责渲染的管道对象实例。资产本身只是一个句柄和存储设置的地方。</p><p>这里创建一个C#脚本，创建一个新的类CustomRenderPipelineAsset，继承RenderPipelineAsset。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CreateAssetMenu可以让这个类成为一种类型的资产，从编辑器菜单栏快捷创建</span></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Rendering/Custom Render Pipeline&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//放回自定义的渲染管线实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在新建菜单项中新建一个RenderPipelineAsset，并在项目设置中选择它</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726174100845.png" alt="image-20240726174100845" title="新建渲染管线资产并设定"></p><h3 id="渲染管线实例"><a href="#渲染管线实例" class="headerlink" title="渲染管线实例"></a>渲染管线实例</h3><p>创建一个类CustomRenderPipeline，并继承RenderPipeline。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span> &#123;</span><br><span class="line">    <span class="comment">//RenderPipeline定义了一个受保护的抽象方法，我们必须重写该方法才能创建具体的管道。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, Camera[] cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法是为自定义 SRP 定义的入口点，但由于相机阵列参数需要每帧分配内存，因此引入了一个替代方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>Unity 在 RP 实例上调用的每一帧。它传递一个上下文结构，该结构提供与引擎的连接，我们可以使用它进行渲染。它还传递一组摄像机，因为场景中可能有多个活动摄像机。RP 负责按照提供的顺序渲染所有这些摄像机。</p><h3 id="相机渲染器"><a href="#相机渲染器" class="headerlink" title="相机渲染器"></a>相机渲染器</h3><p>每个摄像机都是独立渲染的。因此，我们不会渲染所有摄像机，而是将该责任转发给专门用于渲染一个摄像机的新类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span> &#123;</span><br><span class="line"></span><br><span class="line">ScriptableRenderContext context;</span><br><span class="line"></span><br><span class="line">Camera camera;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在CustomRenderPipeline中创建一个CameraRenderer实例，使用它在一个循环中渲染所有摄像机。</p><p><strong><em>CustomRenderPipeline</em></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CameraRenderer renderer = <span class="keyword">new</span> CameraRenderer();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cameras.Count; i++) &#123;</span><br><span class="line">renderer.Render(context, cameras[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制天空盒"><a href="#绘制天空盒" class="headerlink" title="绘制天空盒"></a>绘制天空盒</h3><p>我们首先让CameraRenderer渲染绘制天空盒，这可以通过在上下文中调用相机作为参数来完成。</p><p><strong><em>CameraRenderer</em></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时天空盒子并没有出现，因为我们<strong><em>向上下文发出的命令是缓冲的</em></strong>，我们必须通过调用上下文来<strong><em>提交命令缓冲区渲染命令</em></strong>的工作以供执行。</p><p><strong><em>CameraRenderer</em></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给content发出渲染天空盒子命令</span></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">    <span class="comment">//提交命令缓冲区所有命令</span></span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天空盒子就会出现在场景中，在帧调试器中还能看到它的实际绘制调用。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180309775.png" alt="image-20240726180309775" title="绘制天空盒子"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180330757.png" alt="image-20240726180330757" title="帧调试器结果"></p><p>这里虽然提交了天空盒子的渲染指令，但是最终是否绘制取决于场景中相机的Clear Flags</p><hr><h4 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h4><p>相机的 <code>Clear Flags</code> 属性在 Unity 中用于控制每一帧开始时如何清除之前的渲染内容。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182613555.png" alt="image-20240726182613555"></p><p>这里我们在Build-in管线下测试。</p><h5 id="Solid"><a href="#Solid" class="headerlink" title="Solid"></a>Solid</h5><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182833395.png" alt="image-20240726182833395"></p><p>用指定颜色填充的方式清除颜色缓冲区。</p><h5 id="Depth-Only"><a href="#Depth-Only" class="headerlink" title="Depth Only"></a>Depth Only</h5><p>当相机的 <code>Clear Flags</code> 属性设置为 <code>Depth Only</code> 时，相机会在每一帧开始时只清除深度缓冲区，而不会清除颜色缓冲区。这意味着屏幕上的颜色内容会被保留，但深度信息会被重置。<code>Depth Only</code> 清除模式通常用于多个相机的叠加渲染，确保深度信息不混乱。</p><p>常用场景包括：</p><pre><code>1. 多相机渲染，叠加渲染内容1. 后处理效果</code></pre><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184158104.png" alt="image-20240726184158104"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184210525.png" alt="image-20240726184210525"></p><p>这里两个相机渲染结果叠加了。</p><h5 id="Don’t-Clear"><a href="#Don’t-Clear" class="headerlink" title="Don’t Clear"></a>Don’t Clear</h5><p>不清除缓冲区。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184358837.png" alt="image-20240726184358837"></p><p>这里拖动白球位置，在屏幕上会保留上一帧像素值。</p><hr><p>为了正确渲染天空盒和整个场景，我们必须设置视图投影矩阵。此变换矩阵将摄像机的位置和方向（视图矩阵）与摄像机的透视或正交投影（投影矩阵）相结合。</p><p><strong><em>CameraRenderer</em></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>某些任务（如绘制天空盒）可以通过专用方法发出，但其他命令必须通过单独的命令缓冲区间接发出。我们需要这样一个缓冲区来绘制场景中的其他几何体，因此我们创建一个缓冲区，并用名称来标识它。</p><p><strong><em>CameraRenderer</em></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> bufferName = <span class="string">&quot;Render Camera&quot;</span>;</span><br><span class="line"></span><br><span class="line">CommandBuffer buffer = <span class="keyword">new</span> CommandBuffer &#123;</span><br><span class="line">name = bufferName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用命令缓冲区来注入分析器样本，这些样本将同时显示在分析器和帧调试器中。这是通过在适当的时间点调用来完成的。</p><p>要执行缓冲区，请在上下文上调用缓冲区作为参数。由于执行和清算始终是一起完成的，因此添加一个同时执行这两项操作的方法非常方便。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样开始</span></span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line">   ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样的结束</span></span><br><span class="line">buffer.EndSample(bufferName);</span><br><span class="line">       ExecuteBuffer();</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteBuffer</span> ()</span> &#123;</span><br><span class="line">context.ExecuteCommandBuffer(buffer);</span><br><span class="line">buffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726200112602.png" alt="image-20240726200112602"></p><h3 id="清除渲染目标"><a href="#清除渲染目标" class="headerlink" title="清除渲染目标"></a>清除渲染目标</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">    buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line"></span><br><span class="line">ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制几何图形"><a href="#绘制几何图形" class="headerlink" title="绘制几何图形"></a>绘制几何图形</h3><p>我们目前看到的是天空盒，但看不到我们在场景中放置的任何物体。我们不是绘制每个对象，而是只渲染那些对相机可见的对象。因此，我们可以提出视锥体之外的对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CullingResults cullingResults;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果剔除失败就中止</span></span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">Cull</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//ScriptableCullingParameters 是一个结构体，包含了剔除操作所需的各种参数。</span></span><br><span class="line"><span class="keyword">if</span> (camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters p)) &#123;</span><br><span class="line">           <span class="comment">//执行剔除操作</span></span><br><span class="line">           cullingResults = context.Cull(<span class="keyword">ref</span> p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦我们知道了什么是可见的，我们就可以继续渲染这些东西。这是通过调用上下文来完成的，将<u>剔除结果</u>作为参数，告诉它使用哪个渲染器。除此之外，我们还必须提供<u>绘图设置和过滤设置</u>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings();</span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings();</span><br><span class="line"></span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还没有看到任何内容，因为我们还必须指示允许哪种类型的着色器通道。因此我们必须获取通道的着色器标签ID。</p><p>我们还可以在自定义着色器中定义自己的<code>LightMode</code>标签。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;MyCustomPass&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;MyCustomPass&quot; &#125;</span><br><span class="line">    <span class="comment">// 着色器代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">private static <span class="keyword">readonly</span> ShaderTagId myCustomPassTag = new ShaderTagId(&quot;MyCustomPass&quot;);</span><br></pre></td></tr></table></figure><p>我们在这里支持Unlit着色器渲染。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SRPDefaultUnlit：用于脚本渲染管线的默认无光照通道</span></span><br><span class="line"><span class="keyword">static</span> ShaderTagId unlitShaderTagId = <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;SRPDefaultUnlit&quot;</span>);</span><br><span class="line"><span class="comment">//-----其他通道-----</span></span><br><span class="line"><span class="comment">//ForwardBase：用于前向渲染路径中的基础通道</span></span><br><span class="line"><span class="comment">//ForwardAdd：用于前向渲染路径中的附加光照通道</span></span><br><span class="line"><span class="comment">//ShadowCaster：用于阴影绘制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//控制渲染绘制顺序</span></span><br><span class="line"><span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera);</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">unlitShaderTagId, sortingSettings</span><br><span class="line">);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指出允许的渲染队列</span></span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br></pre></td></tr></table></figure><p>我们能发现Unlit/Transparent材质的物体没有显示，因为这些透明材质没有开启深度写入，在RenderSkyBox时像素值被覆盖了</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205350966.png" alt="image-20240726205350966" style="zoom:50%;"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205433116.png" alt="image-20240726205433116" style="zoom:50%;"></p><h3 id="分别绘制透明和不透明几何图形"><a href="#分别绘制透明和不透明几何图形" class="headerlink" title="分别绘制透明和不透明几何图形"></a>分别绘制透明和不透明几何图形</h3><p>解决方案是先绘制不透明对象，然后绘制天空盒，然后再绘制透明对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    &#123;</span><br><span class="line">        criteria = SortingCriteria.CommonOpaque</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    context.DrawSkybox(camera);</span><br><span class="line"></span><br><span class="line">    sortingSettings.criteria = SortingCriteria.CommonTransparent;</span><br><span class="line">    drawingSettings.sortingSettings = sortingSettings;</span><br><span class="line">    filteringSettings.renderQueueRange = RenderQueueRange.transparent;</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Frame Debugger窗口绘制结果</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726210055545.png" alt="image-20240726210055545"></p><h2 id="编辑器渲染"><a href="#编辑器渲染" class="headerlink" title="编辑器渲染"></a>编辑器渲染</h2><h3 id="绘制传统着色器"><a href="#绘制传统着色器" class="headerlink" title="绘制传统着色器"></a>绘制传统着色器</h3><p>我们如下设置，覆盖所有 Unity 的默认着色器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> ShaderTagId[] legacyShaderTagIds = &#123;</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Always&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;ForwardBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;PrepassBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Vertex&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLMRGBM&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLM&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">);</span><br><span class="line">        <span class="comment">//第2个开始使用SetShaderPassName传递</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; legacyShaderTagIds.Length; i++) &#123;</span><br><span class="line">drawingSettings.SetShaderPassName(i, legacyShaderTagIds[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215013061.png" alt="image-20240726215013061"></p><h3 id="错误材料"><a href="#错误材料" class="headerlink" title="错误材料"></a>错误材料</h3><p>为了清楚地指示哪些对象使用不受支持的着色器，我们将使用 Unity 的错误着色器绘制它们。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errorMaterial == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errorMaterial =</span><br><span class="line">            <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/InternalErrorShader&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">        legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        overrideMaterial = errorMaterial</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215926396.png" alt="image-20240726215926396"></p><h3 id="绘制小工具"><a href="#绘制小工具" class="headerlink" title="绘制小工具"></a>绘制小工具</h3><p>Gizmos应该在其他所有内容之后绘制</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawGizmos</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Handles.ShouldRenderGizmos()) &#123;</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PreImageEffects);</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PostImageEffects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">DrawGizmos();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221445569.png" alt="image-20240726221445569"></p><h3 id="绘制UI"><a href="#绘制UI" class="headerlink" title="绘制UI"></a>绘制UI</h3><p>帧调试器向我们展示了 UI 是单独呈现的，而不是由 RP 呈现的。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221644570.png" alt="image-20240726221644570"></p><p>我们将Canvas组件设置从RenderMode，Screen Space - Overlay【所有图层最上层】变换到Screen Space - Camera，并将其更改为主摄像头并使用主摄像头作为主摄像头，将使其成为透明几何体的一部分。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726225812383.png" alt="image-20240726225812383" style="zoom:50%;"></p><p>如果想要UI显示在场景窗口中，就需要将UI显示添加到世界几何体中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (camera.cameraType == CameraType.SceneView) &#123;</span><br><span class="line">ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为可能会向场景添加几何图形，因此必须在剔除之前完成。</span></span><br><span class="line">   PrepareForSceneWindow();</span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726230354448.png" alt="image-20240726230354448"></p><hr><p><strong>参考文章</strong></p><p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">自定义渲染管线 (catlikecoding.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/165140042">Unity可编程渲染管线（SRP）系列（一）——自定义管线（控制渲染） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity SRP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Start</title>
      <link href="/2024/07/25/Start/"/>
      <url>/2024/07/25/Start/</url>
      
        <content type="html"><![CDATA[<hr><p>故事从20年夏天的风吹起，我用四年的时光走完了故事序章，一路上我做了很多自己想做的事情，一切都听凭本心。</p><p>内心渴望去探索新知识的同时，却又迷茫着，顾虑着未来。</p><p>电子琴、唱歌、摄影、塔罗、运动、日语…这四年，各种事情我都去学习体会，我想更多的感受世界，但是我不可避免的发现，留给我的时间并不是那么充裕。</p><p>在灵犀互娱游戏引擎岗实习的日子，我愈发觉得自己需要尽早变得成熟可靠，我曾跟老大许下承诺，也是我发自内心的渴望，三年后我希望成为一名独当一面的程序员，我希望自己毕业后还是能在游戏行业工作。</p><p>开这个博客，希望能督促自己好好看书，不要颓废，在接下来的研究生生涯中，不留遗憾，把自己想做的事情全都完成。</p><p>大学四年里，从游戏客户端开发、游戏渲染、游戏引擎开发都有所学习，不过都是一些基础的学习而已，之后博客会围绕更进一步学习展开~</p><p>那么故事的正篇就从这里开始叭~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
