<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity SRP 01-自定义管线</title>
      <link href="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/"/>
      <url>/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Unity-SRP-01-自定义管线"><a href="#Unity-SRP-01-自定义管线" class="headerlink" title="Unity SRP 01-自定义管线"></a>Unity SRP 01-自定义管线</h1><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>为了渲染任何东西，必须确定必须绘制哪些形状，在何处、何时以及使用什么设置。这可能会变得非常复杂，具体取决于涉及多少效果。灯光、阴影、透明度、图像效果、体积效果等都必须按照正确的顺序进行处理，才能得到最终图像。这就是渲染管线的作用。</p><p>过去，Unity 仅支持几种内置的渲染方式（Build-in RP）。Unity2018添加了两个使用这种新方法制作的实验性 RP：<u>Lightweight RP and the High Definition RP</u>。在 Unity 2019 中，轻量级 RP 不再是实验性的，而是在 Unity 2019.3 中更名为<u>URP</u>。</p><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>在Unity 2022.3.12f1中创建新的3D项目，并且在场景中放置若干球体，并分别赋予不同材质：</p><ol><li>Unlit&#x2F;Color 黄色</li><li>Unlit&#x2F;Transparent 白色</li><li>Standard（RenderMode:Opaque） 红色</li><li>Standard（RenderMode:Transparent） 蓝色</li></ol><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726172826097.png" alt="image-20240726172826097" title="测试场景"><h3 id="管道资产"><a href="#管道资产" class="headerlink" title="管道资产"></a>管道资产</h3><p>管道资产是为 Unity 提供一种方法来获取负责渲染的管道对象实例。资产本身只是一个句柄和存储设置的地方。</p><p>这里创建一个C#脚本，创建一个新的类CustomRenderPipelineAsset，继承RenderPipelineAsset。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CreateAssetMenu可以让这个类成为一种类型的资产，从编辑器菜单栏快捷创建</span></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Rendering/Custom Render Pipeline&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//放回自定义的渲染管线实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在新建菜单项中新建一个RenderPipelineAsset，并在项目设置中选择它</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726174100845.png" alt="image-20240726174100845" title="新建渲染管线资产并设定"></p><h3 id="渲染管线实例"><a href="#渲染管线实例" class="headerlink" title="渲染管线实例"></a>渲染管线实例</h3><p>创建一个类CustomRenderPipeline，并继承RenderPipeline。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span> &#123;</span><br><span class="line">    <span class="comment">//RenderPipeline定义了一个受保护的抽象方法，我们必须重写该方法才能创建具体的管道。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, Camera[] cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法是为自定义 SRP 定义的入口点，但由于相机阵列参数需要每帧分配内存，因此引入了一个替代方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>Unity 在 RP 实例上调用的每一帧。它传递一个上下文结构，该结构提供与引擎的连接，我们可以使用它进行渲染。它还传递一组摄像机，因为场景中可能有多个活动摄像机。RP 负责按照提供的顺序渲染所有这些摄像机。</p><h3 id="相机渲染器"><a href="#相机渲染器" class="headerlink" title="相机渲染器"></a>相机渲染器</h3><p>每个摄像机都是独立渲染的。因此，我们不会渲染所有摄像机，而是将该责任转发给专门用于渲染一个摄像机的新类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span> &#123;</span><br><span class="line"></span><br><span class="line">ScriptableRenderContext context;</span><br><span class="line"></span><br><span class="line">Camera camera;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在CustomRenderPipeline中创建一个CameraRenderer实例，使用它在一个循环中渲染所有摄像机。</p><p><em><strong>CustomRenderPipeline</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CameraRenderer renderer = <span class="keyword">new</span> CameraRenderer();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cameras.Count; i++) &#123;</span><br><span class="line">renderer.Render(context, cameras[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制天空盒"><a href="#绘制天空盒" class="headerlink" title="绘制天空盒"></a>绘制天空盒</h3><p>我们首先让CameraRenderer渲染绘制天空盒，这可以通过在上下文中调用相机作为参数来完成。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时天空盒子并没有出现，因为我们<em><strong>向上下文发出的命令是缓冲的</strong></em>，我们必须通过调用上下文来<em><strong>提交命令缓冲区渲染命令</strong></em>的工作以供执行。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给content发出渲染天空盒子命令</span></span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">    <span class="comment">//提交命令缓冲区所有命令</span></span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>天空盒子就会出现在场景中，在帧调试器中还能看到它的实际绘制调用。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180309775.png" alt="image-20240726180309775" title="绘制天空盒子"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726180330757.png" alt="image-20240726180330757" title="帧调试器结果"></p><p>这里虽然提交了天空盒子的渲染指令，但是最终是否绘制取决于场景中相机的Clear Flags</p><hr><h4 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h4><p>相机的 <code>Clear Flags</code> 属性在 Unity 中用于控制每一帧开始时如何清除之前的渲染内容。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182613555.png" alt="image-20240726182613555"></p><p>这里我们在Build-in管线下测试。</p><h5 id="Solid"><a href="#Solid" class="headerlink" title="Solid"></a>Solid</h5><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726182833395.png" alt="image-20240726182833395"></p><p>用指定颜色填充的方式清除颜色缓冲区。</p><h5 id="Depth-Only"><a href="#Depth-Only" class="headerlink" title="Depth Only"></a>Depth Only</h5><p>当相机的 <code>Clear Flags</code> 属性设置为 <code>Depth Only</code> 时，相机会在每一帧开始时只清除深度缓冲区，而不会清除颜色缓冲区。这意味着屏幕上的颜色内容会被保留，但深度信息会被重置。<code>Depth Only</code> 清除模式通常用于多个相机的叠加渲染，确保深度信息不混乱。</p><p>常用场景包括：</p><pre><code>1. 多相机渲染，叠加渲染内容1. 后处理效果</code></pre><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184158104.png" alt="image-20240726184158104"></p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184210525.png" alt="image-20240726184210525"></p><p>这里两个相机渲染结果叠加了。</p><h5 id="Don’t-Clear"><a href="#Don’t-Clear" class="headerlink" title="Don’t Clear"></a>Don’t Clear</h5><p>不清除缓冲区。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726184358837.png" alt="image-20240726184358837"></p><p>这里拖动白球位置，在屏幕上会保留上一帧像素值。</p><hr><p>为了正确渲染天空盒和整个场景，我们必须设置视图投影矩阵。此变换矩阵将摄像机的位置和方向（视图矩阵）与摄像机的透视或正交投影（投影矩阵）相结合。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>某些任务（如绘制天空盒）可以通过专用方法发出，但其他命令必须通过单独的命令缓冲区间接发出。我们需要这样一个缓冲区来绘制场景中的其他几何体，因此我们创建一个缓冲区，并用名称来标识它。</p><p><em><strong>CameraRenderer</strong></em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> bufferName = <span class="string">&quot;Render Camera&quot;</span>;</span><br><span class="line"></span><br><span class="line">CommandBuffer buffer = <span class="keyword">new</span> CommandBuffer &#123;</span><br><span class="line">name = bufferName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用命令缓冲区来注入分析器样本，这些样本将同时显示在分析器和帧调试器中。这是通过在适当的时间点调用来完成的。</p><p>要执行缓冲区，请在上下文上调用缓冲区作为参数。由于执行和清算始终是一起完成的，因此添加一个同时执行这两项操作的方法非常方便。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样开始</span></span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line">   ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Submit</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//标记性能采样的结束</span></span><br><span class="line">buffer.EndSample(bufferName);</span><br><span class="line">       ExecuteBuffer();</span><br><span class="line">context.Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteBuffer</span> ()</span> &#123;</span><br><span class="line">context.ExecuteCommandBuffer(buffer);</span><br><span class="line">buffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726200112602.png" alt="image-20240726200112602"></p><h3 id="清除渲染目标"><a href="#清除渲染目标" class="headerlink" title="清除渲染目标"></a>清除渲染目标</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span> ()</span> &#123;</span><br><span class="line">    buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">buffer.BeginSample(bufferName);</span><br><span class="line"></span><br><span class="line">ExecuteBuffer();</span><br><span class="line">context.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制几何图形"><a href="#绘制几何图形" class="headerlink" title="绘制几何图形"></a>绘制几何图形</h3><p>我们目前看到的是天空盒，但看不到我们在场景中放置的任何物体。我们不是绘制每个对象，而是只渲染那些对相机可见的对象。因此，我们可以提出视锥体之外的对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CullingResults cullingResults;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.camera = camera;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果剔除失败就中止</span></span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">Cull</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//ScriptableCullingParameters 是一个结构体，包含了剔除操作所需的各种参数。</span></span><br><span class="line"><span class="keyword">if</span> (camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters p)) &#123;</span><br><span class="line">           <span class="comment">//执行剔除操作</span></span><br><span class="line">           cullingResults = context.Cull(<span class="keyword">ref</span> p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦我们知道了什么是可见的，我们就可以继续渲染这些东西。这是通过调用上下文来完成的，将<u>剔除结果</u>作为参数，告诉它使用哪个渲染器。除此之外，我们还必须提供<u>绘图设置和过滤设置</u>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings();</span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings();</span><br><span class="line"></span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还没有看到任何内容，因为我们还必须指示允许哪种类型的着色器通道。因此我们必须获取通道的着色器标签ID。</p><p>我们还可以在自定义着色器中定义自己的<code>LightMode</code>标签。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;MyCustomPass&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;MyCustomPass&quot; &#125;</span><br><span class="line">    <span class="comment">// 着色器代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">private static <span class="keyword">readonly</span> ShaderTagId myCustomPassTag = new ShaderTagId(&quot;MyCustomPass&quot;);</span><br></pre></td></tr></table></figure><p>我们在这里支持Unlit着色器渲染。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SRPDefaultUnlit：用于脚本渲染管线的默认无光照通道</span></span><br><span class="line"><span class="keyword">static</span> ShaderTagId unlitShaderTagId = <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;SRPDefaultUnlit&quot;</span>);</span><br><span class="line"><span class="comment">//-----其他通道-----</span></span><br><span class="line"><span class="comment">//ForwardBase：用于前向渲染路径中的基础通道</span></span><br><span class="line"><span class="comment">//ForwardAdd：用于前向渲染路径中的附加光照通道</span></span><br><span class="line"><span class="comment">//ShadowCaster：用于阴影绘制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span> ()</span> &#123;</span><br><span class="line">       <span class="comment">//控制渲染绘制顺序</span></span><br><span class="line"><span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera);</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">unlitShaderTagId, sortingSettings</span><br><span class="line">);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指出允许的渲染队列</span></span><br><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br></pre></td></tr></table></figure><p>我们能发现Unlit&#x2F;Transparent材质的物体没有显示，因为这些透明材质没有开启深度写入，在RenderSkyBox时像素值被覆盖了</p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205350966.png" alt="image-20240726205350966" style="zoom:50%;"><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726205433116.png" alt="image-20240726205433116" style="zoom:50%;"><h3 id="分别绘制透明和不透明几何图形"><a href="#分别绘制透明和不透明几何图形" class="headerlink" title="分别绘制透明和不透明几何图形"></a>分别绘制透明和不透明几何图形</h3><p>解决方案是先绘制不透明对象，然后绘制天空盒，然后再绘制透明对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    &#123;</span><br><span class="line">        criteria = SortingCriteria.CommonOpaque</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    context.DrawSkybox(camera);</span><br><span class="line"></span><br><span class="line">    sortingSettings.criteria = SortingCriteria.CommonTransparent;</span><br><span class="line">    drawingSettings.sortingSettings = sortingSettings;</span><br><span class="line">    filteringSettings.renderQueueRange = RenderQueueRange.transparent;</span><br><span class="line"></span><br><span class="line">    context.DrawRenderers(</span><br><span class="line">        cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Frame Debugger窗口绘制结果</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726210055545.png" alt="image-20240726210055545"></p><h2 id="编辑器渲染"><a href="#编辑器渲染" class="headerlink" title="编辑器渲染"></a>编辑器渲染</h2><h3 id="绘制传统着色器"><a href="#绘制传统着色器" class="headerlink" title="绘制传统着色器"></a>绘制传统着色器</h3><p>我们如下设置，覆盖所有 Unity 的默认着色器</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> ShaderTagId[] legacyShaderTagIds = &#123;</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Always&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;ForwardBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;PrepassBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;Vertex&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLMRGBM&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ShaderTagId(<span class="string">&quot;VertexLM&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">);</span><br><span class="line">        <span class="comment">//第2个开始使用SetShaderPassName传递</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; legacyShaderTagIds.Length; i++) &#123;</span><br><span class="line">drawingSettings.SetShaderPassName(i, legacyShaderTagIds[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line">context.DrawRenderers(</span><br><span class="line">cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215013061.png" alt="image-20240726215013061"></p><h3 id="错误材料"><a href="#错误材料" class="headerlink" title="错误材料"></a>错误材料</h3><p>为了清楚地指示哪些对象使用不受支持的着色器，我们将使用 Unity 的错误着色器绘制它们。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawUnsupportedShaders</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errorMaterial == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errorMaterial =</span><br><span class="line">            <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/InternalErrorShader&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(</span><br><span class="line">        legacyShaderTagIds[<span class="number">0</span>], <span class="keyword">new</span> SortingSettings(camera)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        overrideMaterial = errorMaterial</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726215926396.png" alt="image-20240726215926396"></p><h3 id="绘制小工具"><a href="#绘制小工具" class="headerlink" title="绘制小工具"></a>绘制小工具</h3><p>Gizmos应该在其他所有内容之后绘制</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawGizmos</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Handles.ShouldRenderGizmos()) &#123;</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PreImageEffects);</span><br><span class="line">context.DrawGizmos(camera, GizmoSubset.PostImageEffects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span> (<span class="params">ScriptableRenderContext context, Camera camera</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">Setup();</span><br><span class="line">DrawVisibleGeometry();</span><br><span class="line">DrawUnsupportedShaders();</span><br><span class="line">DrawGizmos();</span><br><span class="line">Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221445569.png" alt="image-20240726221445569"></p><h3 id="绘制UI"><a href="#绘制UI" class="headerlink" title="绘制UI"></a>绘制UI</h3><p>帧调试器向我们展示了 UI 是单独呈现的，而不是由 RP 呈现的。</p><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726221644570.png" alt="image-20240726221644570"></p><p>我们将Canvas组件设置从RenderMode，Screen Space - Overlay【所有图层最上层】变换到Screen Space - Camera，并将其更改为主摄像头并使用主摄像头作为主摄像头，将使其成为透明几何体的一部分。</p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726225812383.png" alt="image-20240726225812383" style="zoom:50%;"><p>如果想要UI显示在场景窗口中，就需要将UI显示添加到世界几何体中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span> ()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (camera.cameraType == CameraType.SceneView) &#123;</span><br><span class="line">ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为可能会向场景添加几何图形，因此必须在剔除之前完成。</span></span><br><span class="line">   PrepareForSceneWindow();</span><br><span class="line"><span class="keyword">if</span> (!Cull()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/Unity-SRP-01-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%BA%BF/image-20240726230354448.png" alt="image-20240726230354448"></p><hr><p><strong>参考文章</strong></p><p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">自定义渲染管线 (catlikecoding.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/165140042">Unity可编程渲染管线（SRP）系列（一）——自定义管线（控制渲染） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity SRP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Start</title>
      <link href="/2024/07/25/Start/"/>
      <url>/2024/07/25/Start/</url>
      
        <content type="html"><![CDATA[<hr><p>故事从20年夏天的风吹起，我用四年的时光走完了故事序章，一路上我做了很多自己想做的事情，一切都听凭本心。</p><p>内心渴望去探索新知识的同时，却又迷茫着，顾虑着未来。</p><p>电子琴、唱歌、摄影、塔罗、运动、日语…这四年，各种事情我都去学习体会，我想更多的感受世界，但是我不可避免的发现，留给我的时间并不是那么充裕。</p><p>在灵犀互娱游戏引擎岗实习的日子，我愈发觉得自己需要尽早变得成熟可靠，我曾跟老大许下承诺，也是我发自内心的渴望，三年后我希望成为一名独当一面的程序员，我希望自己毕业后还是能在游戏行业工作。</p><p>开这个博客，希望能督促自己好好看书，不要颓废，在接下来的研究生生涯中，不留遗憾，把自己想做的事情全都完成。</p><p>大学四年里，从游戏客户端开发、游戏渲染、游戏引擎开发都有所学习，不过都是一些基础的学习而已，之后博客会围绕更进一步学习展开~</p><p>那么故事的正篇就从这里开始叭~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
